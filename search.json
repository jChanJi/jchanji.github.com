[{"title":"spark之combineByKey","url":"/year/01/11/combineByKey/","content":"# 函数\n```markdown\ncombineByKey(creatCombiner,mergeValue,mergeCombiners,partitioner)\n```\n# 实例讲解\n## 生成数据\n```markdown\nval scores = sc.parallelize(Array((\"jake\",80.0),\n                                  (\"jake\",90.0),\n                                  (\"jake\",85.0),\n                                  (\"mike\",85.0),\n                                  (\"mike\",92.0),\n                                  (\"mike\",90.0)))\n```\n查看数据\n```markdown\nscores.foreach(println)\n(jake,90.0)\n(jake,80.0)\n(jake,85.0)\n(mike,92.0)\n(mike,85.0)\n(mike,90.0)\n```\n## 求三门总分\n```markdown\nval score2 = scores.combineByKey(score=>(1,score),\n                                (c1:(Int,Double),newScore)=>(c1._1+1,c1._2+newScore),\n                                (c1:(Int,Double),c2:(Int,Double))=>(c1._1+c2._1,c1._2+c2._2))\n```\n查看scores内容\n```markdown\nscore2.foreach(println)\n(mike,(3,267.0))\n(jake,(3,255.0))\n```\n注解：<br>\n1、Int表示科目出现的数目，Double表示第一门与第二门课累加之后的值，newScore表示的是遍历的时候出现的新的分数<br>\n2、当遍历到第二个时因为jake已经遍历过所以调用mergeValue这个参数，科目数变为 +1 分数也变为和newScore之和<br>\nmergeCombiner:c1和c2的科目数和分数相加（所有key相同的value相加）<br>\n3、partitioner一般用不到\n\n## 求平均分\n```markdown\nval average = score2.map{case(name,(num,score))=>(name,score/num)}\naverage.foreach(println)\n```\n运行结果\n```markdown\n(mike,89.0)\n(jake,85.0)\n```\n","tags":["spark"],"categories":["-bigdata"]},{"title":"scala 运行spark程序","url":"/year/01/11/idea使用scala运行spark计数/","content":"# 环境配置\n## 配置maven镜像地址\n```markdown\n<mirror>\n    <id>alimaven</id>\n    <name>aliyun maven</name>\n    <url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n    <mirrorOf>central</mirrorOf>      \n</mirror>\n```\n## sbt仓库地址\n编辑~/.sbt/repositories（没有就新建）\n```markdown\n[repositories]\nlocal\ndl bintray: https://dl.bintray.com/typesafe/ivy-releases/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly\njcenter: https://jcenter.bintray.com/\ntypesafe-ivy-releases: https://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly\nmaven-central\nsonatype-snapshots: https://oss.sonatype.org/content/repositories/snapshot\n```\n# 版本\n>jdk1.8\n\n>spark 2.2  \n\n>scala 2.11.11\n\n>sbt0.13.16\n\n# sbt依赖\nbuild.sbt文件内容为\n```markdown\n    name := \"scala_test\"\n    version := \"1.0\"\n    scalaVersion := \"2.11.11\" #后面不需要配置\n    libraryDependencies ++= Seq(\"org.apache.spark\" %% \"spark-core\" % \"2.2.0\")\n    libraryDependencies += \"org.apache.spark\" % \"spark-streaming_2.11\" % \"2.2.0\"  \n    libraryDependencies += \"org.apache.spark\" % \"spark-mllib_2.11\" % \"2.2.0\"  \n    libraryDependencies += \"org.apache.spark\" % \"spark-sql_2.11\" % \"2.2.0\"  \n    libraryDependencies += \"org.apache.spark\" % \"spark-streaming-kafka-0-8_2.11\" % \"2.2.0\"  \n    libraryDependencies += \"org.apache.spark\" % \"spark-streaming-flume_2.11\" % \"2.2.0\"  \n    libraryDependencies += \"org.apache.spark\" % \"spark-hive_2.11\" % \"2.2.0\" % \"provided\"  \n    libraryDependencies += \"org.scalanlp\" % \"breeze_2.11\" % \"0.11\"  \n    libraryDependencies += \"org.scalanlp\" % \"breeze-natives_2.11\" % \"0.11\"  \n    libraryDependencies += \"org.apache.hadoop\" % \"hadoop-common\" % \"2.6.0\"\n```\n然后使用sbt打包,如下图所示\n\n![图一](https://raw.githubusercontent.com/jChanJi/static_resource/master/img/1.png)\n\n**注意本机实验的时候一定要先登录localhost的ssh不然到提交作业的时候会没有权限写入文件**\n\n# 运行服务\n```markdown\n./sbin/start-master.sh # 启动spark\n./bin/spark-class org.apache.spark.deploy.worker.Worker spark://localhost.localdomain:7077 # 启动worker, spark://localhost.localdomain:7077到8080端口查看   \n./bin/spark-submit --master spark://localhost.localdomain:7077  --class WordCount /home/chanji/scala_test.jar # 提交作业\n　\n```\n再到http://localhost:8080/jobs 查看作业\n# 问题\n## 无法解析主机名\n> 无法解析主机：promote.cache-dns.local＜br>\n\n>hostname分为三种类型：<br>\n静态的（static），瞬态的（transient），和灵活的（pret不然ty）<br>\n执行系统命令hostname得到的是瞬态的主机名，扫描文件中得到的是静态主机名。<br>\n将这两者统一起来就可以解决问题了。<br>\n1.自定义hostname，假设myname<br>\n2.执行hostnamectl set-hostname myname<br>\n这个命令能同时修改三种类型的主机名定义。<br>\n重启\n\n# 基础知识\n>Drive program 是程序的入口,包含这main函数\ncontext起着和集群连接的作用\nRDDs　弹性分布式数据集,实质就是一个数据集，指向一个变量，数据集可以被分为若干部分存在与不同的主机上，但操作这些数据只能通过定义的数据集变量。\n","tags":["spark"],"categories":["-bigdata"]},{"title":"ubuntu下Docker的安装和使用","url":"/year/01/10/docker/","content":"\n# 安装环境检查\n```markdown\nuname -a\nls -l /sys/class/misc/device-mapper\n```\n<!--more-->\n# 使用ubuntu apt-get安装\n```makdown\nsudo apt-get update\nsudo apt-get install docker.io\nsource /etc/bash_completion.d/docker.io\n```\n>由于使用ubuntu安装不是最新的版本所以使用docker提供的方法安装，先卸载\n# apt安装的卸载\n```makdown\nsudo apt-get remove docker\nsudo apt-get remove --auto-remove docker  \nsudo apt-get remove --purge docker.io  \nsudo apt-get autoremove --purge\n```\n# docker提供的方式安装\n## 安装crul\n```markdown\nsudo apt-get install -y curl\n```\n## 安装docker\n```markdown\ncurl -fsSL get.docker.com -o get-docker.sh\n```\n如果报错没有source.list文件则新建\n```markdown\n    sudo sh get-docker.sh\n```\ndocker默认只能由root权限运行，所以给当前用户权限\n```markdown\nsudo usermod -aG docker your-user\n```\n创建docker组并将当前用户加入组\n```markdown\nsudo groupadd docker\nsudo usermod-aG docker $USERE\n```\n修改镜像源地址为Daocloud\n\n```markdown\n curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://efd9e468.m.daocloud.io\n```\n#　docker安装版本的卸载\n```markdwown\n sudo apt-get purge docker-ce\n sudo rm -rf /var/lib/docker\n```\n# 常用的命令\n```markdwn\ndocker run nginx #运行容器\ndocker images  #查看镜像\ndocker run -p 8080:80 -d daocloud.io/nginx #在8080：80端口使用Daemon模式运行以daocloud.io/nginx为镜像的容器\ndocker ps\nsudo vim index.html\n```\n在index.html中写\n```html\n<html>\n<h1>Docker is fun</h1>\n</html>\n```\n将文件上传到docker的容器中\n```markdown\ndocker cp index.html 3a90426cbb80://usr/share/nginx/html  #其中‘3a90426cbb80’是容器号，后面是容器中文件地址\ndocker stop 3a90426cbb80　#停止容器\n```\n当我们再次运行容器的时候发现是一开始未改动的结果，因为docker在容器内作的改动都是暂时的，不会保存下来,如果需要保存则要生成一个新的容器\n```markdown\ndocker commit -m \"fun\" 4138300aa8eb nginx-fun # nginx-fun为新容器的名字\n```\n```markdown\ndocker ps #查看当前运行的容器\ndocker ps -aq #相当于列出所有的容器ID，然后docker rm它们\ndocker pull #获取image\ndocker build #创建image\ndocker images #列出images\ndocker run #运行container\ndocker ps #列出container\ndocker rm # 删除container\ndocker rmi # 删除image\ndocker cp # 在host和container之间拷贝文件\ndocker commit 保存改动为新的image\n```\n# 通过dockerfile创建容器\n## 简单的例子\n```markdown\nvim Dockerfile\n```\n在其中写入\n```markdown\nFROM alpine:latest #基础镜像，alpine是专门针对linux的非常小的镜像\nMAINTAINER chanji　#用户声明\nCMD echo \"hello Docker\" #执行命令\n```\nbuild镜像\n```markdown\nbuild -t hello_docker . # -t　标签参数; '.' 意思为文件路径下所有内容都送给docker engine\ndocker run hello_docker #生成镜像后运行\n```\n可以看到结果  \n```markdown\nhello Docker\n```\n## 稍微复杂的例子\n```markdown\nmkdir Dockerfile2\ncd Dockerfile2\nvim Dockerfile\n```\n在其中写入\n```markdown\nFROM ubuntu\nMAINTAINER chanji\nRUN apt-get update\nRUN　apt-get install -y nginx\nCOPY　index.html /var/www/html\nENTRYPOINT　[\"/usr/sbin/nginx\",\"-g\",\"daemon off;\"]  #将nginx在前台执行\nEXPOSE 80\n```\n再编辑index.html文件\n```markdown\nvim index.html\n```\n在其中写入\n```markdown\nhello docker\n```\n```markdown\ndocker build -t chanji/hello-nginx . #构建\ndocker run -d -p 80:80 chanji/hello-nginx #以deamon模式在80:80端口运行\ncurl http://localhost #显示index.html中的信息hello docker\n```\n## dockerfile简单语法\n\n关键字 | 含义\n------|-----\nFROM  |基础镜像\nRUN　　 |执行命令\nADD   |添加文件\nCOPY  |拷贝文件\nCMD　　　|执行命令\nEXPSOE|暴露端口\nWORKDIR|指定路径     \nMAINTAINER|　维护者\nENV   | 设定环境变量\nUSER　　|制定用户\nVOLUME|mount point挂载的卷\n\n# 镜像分层\n> dockerfile中的每一行语句都有id,分层存储，已有的镜像是只读的，运行生成容器的时候容器有读写权限\n\n# Volume\n>提供独立于程序之外的持久化存储，即将容器运行时的数据保存下来，这样就不用重新生成新的容器\n\n## 将本地文件位置挂在到docker容器内的位置,本地路径默认的\n```markdown\ndocker run -d --name nginx -v /usr/share/nginx/html nginx # -d :表示开启Daemon模式,--name: 名称, -v [容器内路径] [基础镜像]: 基础镜像中挂载卷的位置\ndocker aspect nginx # 查看容器信息中mount的host的地址\nsu # 进入root\ncd /var/lib/docker/volumes/6f01d9e35da52f4a8157f9e2099937cb9040a351b6a327fd3a69b53065836bcb/data # 可以看到当中的信息与nginx容器挂载路径下的内容一致\necho \"hello volum!\" > index.html # 将内容写入到本地挂载的文件\ndocker exec -it nginx /bin/bash #进入docker容器\ncd /usr/share/nginx/html # 打开目录\ncat index.html # 发现文件已经改变\n```\n## 将本地目录挂载在容器中的指定位置，本地路径自己定义\n```markdown\ndocker ps\ndocker stop 776eee319d2b #停止占用80端口的容器\nmkdir -p /vol/html\ncd /vol/html\nvim index.html # 在其中添加内\ncd .. # 到上一级目录\ndocker run -p 80:80 -d -v $PWD/html:/usr/share/nginx/html nginx # 将当前目录下的html文件夹挂载到nginx容器的/usr/share/nginx/html目录\nvim /html/index.html #修改其中内容为hello volume\ncurl localhost # 发现和刚才修改的内容一致\n```\n## 创建一个仅有数据的容器，并将此容器挂载到其他容器\n```markdown\nmkdir -p /vol2/data\ndocker create  -v $PWD/vol2/data:/var/mydata --name data_container ubuntu #创建一个容器，名为data_container，将本地目录挂载在其相应目录，基础镜像为ubuntu\ndocker run -it --volumes-form data_container ubuntu /bin/bash #运行一个新的容器，将数据容器挂载在新的容器上，并进入交互模式\nmount #查看挂载，发现有/var/mydata目录\ncd /var/mydata\ntouch hello.txt\nCrtl + d #退出容器\ncd data\nls # 出现了hello.txt文件\n```\n\n# Registry\n```markdown\ndocker search whalesay #搜索镜像\ndocker pull docker/whalesay # 将镜像pull下来,REPOSITORY可以理解为镜像的名字\ndocker run docker/whalesay cowsay Docker很好玩 #运行容器,调用cowsay，可以打印出鲸鱼和文字\ndocker tag docker/whalesay chanji/whalesay # 产生和docker/whalesay镜像相同的dockerID/whalesay镜像\ndocker login # dockerhub的用户名和密码，需要注册，很卡\ndocker push chanji/whalesay #上传到镜像库\n```\n\n# compose\n>多容器app\n\n## 安装docker-compose\n```markdown\nsu #进入root模式\ncurl -L https://github.com/docker/compose/releases/download/1.9.0/docker-compose-$(uname -s)-$(uname -m) > /usr/local/bin/docker-compose # 将二进制文件写入到bin中\nchmod a+x /usr/local/bin/docker-compose　#修改权限为可执行\ndocker-compose --version　#查看版本\n```\n## 创建多容器app\n```markdown\nmkdir ghost\ncd ghost\nmkdir ghost\nmkdir nginx\nmkdir data\ncd ghost\nvim Dockerfile\n```\n其内容为\n```markdown\nFROM ghost\nCOPY ./config.js /var/lib/ghost/config.js\nEXPOSE 2368\nCMD [\"npm\",\"start\",\"--production\"]\n```\n编辑config.js\n```marldown\nvim config.js\n```\n内容为\n```markdown\nvar path = require('path'),\nconfig;\n\nconfig = {\nproduction: {\n    url: 'http://mytestblog.com',   \n    mail:{},\n    database: {\n        client: 'mysql',\n        connection: {\n            host:'db',\n            user:'ghost',\n            password:'ghost',\n            database:'ghost,\n            port:'3306',\n            charset:'utf8',\n       },\n    debug: false\n    },\n    paths:{\n        contentPath: path.join(process.env.GHOST_CONTENT, '/')\n    },\n    server: {\n    host:'0.0.0.0',\n    port:'2368'\n    }\n   }\n};\nmodule.exports = config;\n```\n编辑nginx模块\n```markdown\ncd ../nginx\nvim Dockerfile\n```\n内容为\n```markdown\nFROM nginx\nCOPY nginx.conf /etc/nginx/nginx.conf\nEXPOSE 80      \n```\n配置nginx.conf\n```markdown\nvim nginx.config\n```\n内容为\n```markdown\nworker_processes 4;\nevents {worker_connections 1024;}\nhttp{\n    server{\n        listen 80;\n    location /{\n        proxy_pass http://ghost-app:2368;\n    }\n    }\n}\n```\n准备一个compose文件\n```markdown\ncd .. #进入第一层的ghost目录\nvim docker-compose.yml\n```\n其内容为\n```markdown\nversion: '2'\nnetworks:\n    ghost:\nservices:\n    ghost-app:\n        build: ghost\n        networks:\n            - ghost\n        depends_on:\n            - db\n        ports:\n            - \"2368:2368\"\n    nginx:\n        build: nginx\n        networks:\n            - ghost\n        depends_on:\n            - ghost-app\n        ports:\n            - \"80:80\"\n    db:\n        image: \"mysql:5.7.15\"\n        networks:\n            - ghost\n        environment:\n            MYSQL_ROOT_PASSWORD: mysqlroot\n            MYSQL_USER: ghost\n            MYSQL_PASSWORD: ghost\n        volumes:\n            - $PWD/data:/var/lib/mysql\n        ports:\n            - \"3360:3360\"    \n```\n上面的代码注意缩进和‘－'后的空格。文件下载[docker-compsoe.yml](https://raw.githubusercontent.com/jChanJi/static_resource/master/docker/docker-compose.yml)<br>\n如果运行结果显示80端口被占用，docker stop [id]停止占用端口的容器\n```markdown\ndocker-compose stop #先停掉拉起来的服务\ndocker-compose rm #删除停掉的服务\ndocker-compose build　＃第一次未生成镜像时会自动构建，但是出错后不会再自动构建，需要build\ndocker-compose up -d #再一次的拉起服务\n```\n上述命令必须在ghost的文件中执行<br>\n以上配置基本完成，打开浏览器\n```markdown\nlocalhost #打开浏览器输入lcoalhost，出现ghost页面则成功\nlocalhost/ghost #配置ghost路径\n```\n下面给出几张成功的页面\n![image1](https://raw.githubusercontent.com/jChanJi/static_resource/master/img/ghost.png)\n\n![mage2](https://raw.githubusercontent.com/jChanJi/static_resource/master/img/ghost2.png)\n\n![image3](https://raw.githubusercontent.com/jChanJi/static_resource/master/img/ghost3.png)\n# 总结\n> docker作为目前极为流行的环境部署容器,使用起来确实是方便快捷效率高,以上使用了多app容器实现了mysql,ghost和数据容器的整合，只需要一些简单的命令便可以搭建起来一个服务。\n","tags":["docker"],"categories":["-others"]},{"title":"对四维的鸢尾花数据使用PCA进行降维","url":"/year/01/09/pca/","content":"\n## 前言：\n>此篇笔记主要根据南京大学礼欣老师的[《Python机器学习应用》](http://www.icourse163.org/learn/BIT-1001872001?tid=1001965001#/learn/announce)整理而成，详细内容请看礼欣老师的mooc课程。\n\n## 数据介绍：\n对四维的鸢尾花数据使用PCA进行降维并且可视化，数据格式如下：\n![图1](https://raw.githubusercontent.com/jChanJi/static_resource/master/img/iris.PNG)\n<!--more-->\n## 代码\n```python\nimport matplotlib.pyplot as plt\nfrom sklearn.decomposition import PCA\nfrom sklearn.datasets import load_iris\n\ndata = load_iris()\ny = data.target\nX = data.data\npca = PCA(n_components=2)\nreduced_X = pca.fit_transform(X)\n\nred_x, red_y = [], []\nblue_x, blue_y = [], []\ngreen_x, green_y = [], []\n\nfor i in range(len(reduced_X)):\n    if y[i] == 0:\n        red_x.append(reduced_X[i][0])\n        red_y.append(reduced_X[i][1])\n    elif y[i] == 1:\n        blue_x.append(reduced_X[i][0])\n        blue_y.append(reduced_X[i][1])\n    else:\n        green_x.append(reduced_X[i][0])\n        green_y.append(reduced_X[i][1])\n\nplt.scatter(red_x, red_y, c='r', marker='x')\nplt.scatter(blue_x, blue_y, c='b', marker='D')\nplt.scatter(green_x, green_y, c='g', marker='.')\nplt.show()\n\n```\n\n## 结果\n![图1](https://raw.githubusercontent.com/jChanJi/static_resource/master/img/iris_res.PNG)\n","tags":["PCA"],"categories":["-machinelearning"]},{"title":"聚类算法DBSCAN实现大学生上网时长分类","url":"/year/01/09/studentOnline_timeslot/","content":"\n## 前言：\n>此篇笔记主要根据南京大学礼欣老师的[《Python机器学习应用》](http://www.icourse163.org/learn/BIT-1001872001?tid=1001965001#/learn/announce)整理而成，详细内容请看礼欣老师的mooc课程。\n\n<!--more-->\n\n## 数据介绍：\n现有大学校园网的日志数据，290条大学生的校园网使用情况数据，数据包\n括用户ID，设备的MAC地址，IP地址，开始上网时间，停止上网时间，上\n网时长，校园网套餐等。利用已有数据，分析学生上网的模式。数据下载[点击我](https://github.com/jChanJi/jchanji.github.com/tree/master/meterial/data/clustering)\n\n\n\n## 主要参数\n### eps: 两个样本被看作邻居节点的最大距离\n### min_samples: 簇的样本数\n### metric：距离计算方式\n\n## 上网时间段\n### 代码\n\n```python\nimport numpy as np\nimport sklearn.cluster as skc\nfrom sklearn import metrics\nimport matplotlib.pyplot as plt\n\nmac2id=dict()\nonlinetimes=[]\nf=open('F:\\data\\clustering\\TestData.txt',encoding='utf-8')\nfor line in f:\n    mac=line.split(',')[2]\n    onlinetime=int(line.split(',')[6])\n    starttime=int(line.split(',')[4].split(' ')[1].split(':')[0])\n    if mac not in mac2id:\n        mac2id[mac]=len(onlinetimes)\n        onlinetimes.append((starttime,onlinetime))\n    else:\n        onlinetimes[mac2id[mac]]=[(starttime,onlinetime)]\nreal_X=np.array(onlinetimes).reshape((-1,2))\n\nX=real_X[:,0:1]\n\ndb=skc.DBSCAN(eps=0.01,min_samples=20).fit(X)\nlabels = db.labels_\n\nprint('Labels:')\nprint(labels)\nraito=len(labels[labels[:] == -1]) / len(labels)\nprint('Noise raito:',format(raito, '.2%'))\n\nn_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)\n\nprint('Estimated number of clusters: %d' % n_clusters_)\nprint(\"Silhouette Coefficient: %0.3f\"% metrics.silhouette_score(X, labels))\n\nfor i in range(n_clusters_):\n    print('Cluster ',i,':')\n    print(list(X[labels == i].flatten()))\n\n\nplt.hist(X,24)\nplt.show()\n```\n\n### 结果\n\n```markdown\nLabels:\n[ 0 -1  0  1 -1  1  0  1  2 -1  1  0  1  1  3 -1 -1  3 -1  1  1 -1  1  3  4\n -1  1  1  2  0  2  2 -1  0  1  0  0  0  1  3 -1  0  1  1  0  0  2 -1  1  3\n  1 -1  3 -1  3  0  1  1  2  3  3 -1 -1 -1  0  1  2  1 -1  3  1  1  2  3  0\n  1 -1  2  0  0  3  2  0  1 -1  1  3 -1  4  2 -1 -1  0 -1  3 -1  0  2  1 -1\n -1  2  1  1  2  0  2  1  1  3  3  0  1  2  0  1  0 -1  1  1  3 -1  2  1  3\n  1  1  1  2 -1  5 -1  1  3 -1  0  1  0  0  1 -1 -1 -1  2  2  0  1  1  3  0\n  0  0  1  4  4 -1 -1 -1 -1  4 -1  4  4 -1  4 -1  1  2  2  3  0  1  0 -1  1\n  0  0  1 -1 -1  0  2  1  0  2 -1  1  1 -1 -1  0  1  1 -1  3  1  1 -1  1  1\n  0  0 -1  0 -1  0  0  2 -1  1 -1  1  0 -1  2  1  3  1  1 -1  1  0  0 -1  0\n  0  3  2  0  0  5 -1  3  2 -1  5  4  4  4 -1  5  5 -1  4  0  4  4  4  5  4\n  4  5  5  0  5  4 -1  4  5  5  5  1  5  5  0  5  4  4 -1  4  4  5  4  0  5\n  4 -1  0  5  5  5 -1  4  5  5  5  5  4  4]\nNoise raito: 22.15%\nEstimated number of clusters: 6\nSilhouette Coefficient: 0.710\nCluster  0 :\n[22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22]\nCluster  1 :\n[23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23]\nCluster  2 :\n[20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20]\nCluster  3 :\n[21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21]\nCluster  4 :\n[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]\nCluster  5 :\n[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]\n\n```\n\n![图一](https://raw.githubusercontent.com/jChanJi/static_resource/master/img/stuonline1.PNG)\n## 上网时长\n### 代码\n```python\nimport numpy as np\nimport sklearn.cluster as skc\nfrom sklearn import metrics\nimport matplotlib.pyplot as plt\n\nmac2id=dict()\nonlinetimes=[]\nf=open('F:\\data\\clustering\\TestData.txt',encoding='utf-8')\nfor line in f:\n    mac=line.split(',')[2]\n    onlinetime=int(line.split(',')[6])\n    starttime=int(line.split(',')[4].split(' ')[1].split(':')[0])\n    if mac not in mac2id:\n        mac2id[mac]=len(onlinetimes)\n        onlinetimes.append((starttime,onlinetime))\n    else:\n        onlinetimes[mac2id[mac]]=[(starttime,onlinetime)]\nreal_X=np.array(onlinetimes).reshape((-1,2))\n\nX=np.log(1+real_X[:,1:])\ndb = skc.DBSCAN(eps=0.14,min_samples=10).fit(X)\nlabels = db.labels_\n\nprint('Labels:')\nprint(labels)\nratio=len(labels[labels[:] == -1])/len(labels)\nprint('Noise raito:',format(ratio,'.2%'))\n\nn_clusters_ = len(set(labels))-(1 if -1 in labels else 0)\n\nprint('Estimated number of clusters: %d' % n_clusters_)\nprint(\"Silhouette Coefficient :%0.3f\"% metrics.silhouette_score(X, labels))\n\nfor i in range(n_clusters_):\n    print('Cluster',i,':')\n    count = len(X[labels ==i])\n    mean = np.mean(real_X[labels == i][:,1])\n    std=np.std(real_X[labels ==i][:,1])\n    print('\\t number of sample : ',count)\n    print('\\t mean of sample: ',format(mean,'.1f'))\n    print('\\t std of sample: ',format(std,'.1f'))\n\nplt.hist(X,24)\nplt.show()\n```\n### 结果\n```markdown\nLabels:\n[ 0  1  0  4  1  2  0  2  0  3 -1  0 -1 -1  0  3  1  0  3  2  2  1  2  0  1\n  1 -1 -1  0  0  0  0  1  0 -1  0  0  0  2  0  1  0 -1 -1  0  0  0  3  2  0\n -1  1  0  1  0  0 -1  2  0  0  0  1  3  3  0  2  0 -1  3  0  0  2  0  0  0\n  2  1 -1  0  0  0  0  0  0  1 -1  0  3  1  0  1  1  0  1  0  1  0  0 -1  1\n  1  0  0  2  0  0  0  2  2  0  0  0 -1  0  0  4  0  1  2 -1  0  1  0  2  0\n -1 -1 -1  0  1  1  3 -1  0  1  0  2  0  0  2  1  1  0  0  0  0  4 -1  0  0\n  0  0  2  0  0  0  0 -1  2  0  0  0  0  4  0  0 -1  0  2  0  0 -1  0  1  4\n  0  0 -1  1  1  0  0  2  0  0  3 -1 -1 -1  1  0  0  2  1  0 -1 -1  3  2  2\n  0  0  3  0  1  0  0  0  3  2  0 -1  0  1 -1 -1  0  2  2  1  4  0  0  1  0\n  2  0  0  0  0  1  1  0  0  1  0  4 -1 -1  0  0  0 -1 -1  1 -1  4 -1  0  2\n  2 -1  2  1  2 -1  0 -1  0  2  2  1 -1  0  1  2 -1 -1  1 -1  2 -1 -1  1  4\n  2  3  1  0  4  0  0  4  2  4  0  0  2 -1]\nNoise raito: 16.96%\nEstimated number of clusters: 5\nSilhouette Coefficient :0.227\nCluster 0 :\n     number of sample :  128\n     mean of sample:  5864.3\n     std of sample:  3498.1\nCluster 1 :\n     number of sample :  46\n     mean of sample:  36835.1\n     std of sample:  11314.1\nCluster 2 :\n     number of sample :  40\n     mean of sample:  843.2\n     std of sample:  242.9\nCluster 3 :\n     number of sample :  14\n     mean of sample:  16581.6\n     std of sample:  1186.7\nCluster 4 :\n     number of sample :  12\n     mean of sample:  338.4\n     std of sample:  31.9\n```\n\n![图二](https://raw.githubusercontent.com/jChanJi/static_resource/master/img/stuonline2.PNG)\n","tags":["DBSCAN"],"categories":["-machinelearning"]},{"title":"NMF和PCA算法对人脸进行特征提取并且进行对比","url":"/year/01/09/NMF_PCA/","content":"\n## 前言：\n>此篇笔记主要根据南京大学礼欣老师的[《Python机器学习应用》](http://www.icourse163.org/learn/BIT-1001872001?tid=1001965001#/learn/announce)整理而成，详细内容请看礼欣老师的mooc课程。\n\n## 数据介绍：\n分别使用NMF和PCA算法对人脸进行特征提取并且进行对比\n<!--more-->\n\n## 代码\n```python\nfrom sklearn import decomposition\n\n\nn_row, n_col = 2, 3\nn_components = n_row * n_col\nimage_shape = (64, 64)\n\n\n###############################################################################\n# Load faces data\ndataset = fetch_olivetti_faces(shuffle=True, random_state=RandomState(0))\nfaces = dataset.data\n\n###############################################################################\ndef plot_gallery(title, images, n_col=n_col, n_row=n_row):\n    plt.figure(figsize=(2. * n_col, 2.26 * n_row))\n    plt.suptitle(title, size=16)\n\n    for i, comp in enumerate(images):\n        plt.subplot(n_row, n_col, i + 1)\n        vmax = max(comp.max(), -comp.min())\n\n        plt.imshow(comp.reshape(image_shape), cmap=plt.cm.gray,\n                   interpolation='nearest', vmin=-vmax, vmax=vmax)\n        plt.xticks(())\n        plt.yticks(())\n    plt.subplots_adjust(0.01, 0.05, 0.99, 0.94, 0.04, 0.)\n\n\nplot_gallery(\"First centered Olivetti faces\", faces[:n_components])\n###############################################################################\n\nestimators = [\n    ('Eigenfaces - PCA using randomized SVD',\n         decomposition.PCA(n_components=6,whiten=True)),\n\n    ('Non-negative components - NMF',\n         decomposition.NMF(n_components=6, init='nndsvda', tol=5e-3))\n]\n\n###############################################################################\n\nfor name, estimator in estimators:\n    print(\"Extracting the top %d %s...\" % (n_components, name))\n    print(faces.shape)\n    estimator.fit(faces)\n    components_ = estimator.components_\n    plot_gallery(name, components_[:n_components])\n\nplt.show()\n\n```\n\n## 结果\n```markdown\ndownloading Olivetti faces from http://cs.nyu.edu/~roweis/data/olivettifaces.mat to C:\\Users\\ChanJi\\scikit_learn_data\nExtracting the top 6 Eigenfaces - PCA using randomized SVD...\n(400, 4096)\nExtracting the top 6 Non-negative components - NMF...\n(400, 4096)\n```\n![图1](https://raw.githubusercontent.com/jChanJi/static_resource/master/img/face_ori.PNG)\n![图2](https://raw.githubusercontent.com/jChanJi/static_resource/master/img/face_PCA.PNG)\n![图3](https://raw.githubusercontent.com/jChanJi/static_resource/master/img/face_NMF.PNG)\n","tags":["NMF"],"categories":["-machinelearning"]},{"title":"Single Shot MultiBox Detector翻译","url":"/year/12/29/SSD-tensorflow/","content":"## 前言\n> 毕设的课题为基于SSD的深度学习目标检测研究，首先要对SSD框架的思想做到非常的了解，借此机会准备详细的翻译理解一下SSD的内容，如有错误指出，欢迎指出。原文链接：[https://arxiv.org/abs/1512.02325](点我)\n\n## 翻译\n### Abstract\n> 我们展示了使用单层神经网络来检测图片中的物体的方法，称之为SSD,它将输出空间的bounding boxes (边界框)离散化为每一个特征图上的一系列不同纵横比和尺寸的（default boxes）默认框。在进行预测的时候，神经网络会对每个默认框中的每一个物体种类的存在形成一个分数，并且对默认框进行调整以更好的匹配目标的形状 。另外，这个网络还用了不同的方法来联合不同特征图上的预测结果以自然的解决不同尺寸的物体。SSD是一个相对简单的方法，它需要候选对象，因为它完全排除了生成候选对象和接下来对像素和特征重新采样的阶段并且将所有的计算都压缩在了一个单层网络里。这让SSD很容易的训练并且直接的应用到需要检测组件的系统中去。在PASACAL、VOC、COCO和ILASVRC数据集上的实验证明了SSD在精确度上和那些利用额外的候选目标步骤的方法相比很有竞争力并且更快，于此同时SSD还为训练和接口提供了一个统一的框架。，对PASCAL VOC 2007的数据集，在300×300像素的尺寸输入，SSD在Nvidia Titan X上59FPS时达到72.1％的mAP，500×500像素尺寸输入SSD达到75.1％的mAP，超过了相比较的state of art 模型Faster R-CNN 。和其他的单个步骤的方法相比，SSD对于更小尺寸图片的输入有着更好的检出率。\n<!--more-->\n### The Single Shot Detector (SSD)\n\n> 在模型的训练期间中只需要输入原图和ground truth boxes（真实边框图）（如：图四 (a)）。卷积处理中，在许多不同尺寸的特征图（例如8x8 feature map和4x4 feature map）中评估出一系列不同宽比的边界框值，其中默认的为四个，对于每一个默认框评估出所有目标的形状偏移和置信度。在训练时，我们首先将这些默认框匹配到真实标签框。这些框为正，其余视为负。模型损失是定位损失和置信损失之间的加权和。\n\n![feature map](https://raw.githubusercontent.com/jChanJi/static_resource/master/SSD/feature_map.PNG)\n\n### model\n> SSD基于前馈卷积网络，其产生固定大小的边界框集合和框中对象类别的分数，接着是非最大化抑制步骤以产生最终检测。早期的网络基于使用高质量图片分类的标准结构，我们称之为基础网络。后来在基础网络的上进行了改进加上了辅助结构(图四 SSD的Extra Feature Layers部分)。其中关键的特征如下：\n\n> ⑴在检测的时候使用不同尺寸的特征图<br>\n在被删去的基础网络后面加上了卷积特征层，这些特征层减少了逐渐增多的\n尺寸并且能够对不同尺寸的对象进行预测。这个预测检测目标的卷积模型每一个特征层都和YOLO不相同。\n\n> ⑵检测的卷积预测器<br>\n每一个添加了特征层或者从基础网络中选择了一个特征层的网络能够使用一个卷积过滤器的集合产生一个预测目标的确定集合。在图五SSD模型的顶部表明了这一特点。对一个m x n并且有p个通道的特征层来说，用来预测潜在目标的参数的基础元素有3 x 3 x p个小核心，它用来产生分数或者种类或者相对于默认框的相对形状偏移量。在每个核心应用到的m x n区域内它产生一个输出值。\n边界框偏移量的输出值是相对与默认框的位置和特征图的位置测量的，而YOLO在这一步中使用中间全连接层而不是卷积过滤器。\n与YOLO相比，他有如下的特征：首先它在基础网络的后面加上了一些特征层，从而能够对默认框的不同尺寸和方面的比例和他们置信联系的偏移进行预测。在VOC2007测试数据集上，SSD对于300x300尺寸的输入图片的训练结果远远的超过了YOLO对于424x425尺寸图片的训结果，并且在速度上也有很大的改进。\n\n> ⑶默认框和纵横比<br>\n针对网络顶部的多特征图，我们将默认的边界框集合和每一个特征图单元联系起来。默认框使用卷积的方式拼接特征图所以每一个默认框的位置相对于他对应的单元是固定的。在每一个特征图单元中我们能够预测每个单元中相对于默认框的形状偏移量和在每一个边框中表明一个类实体存在的分数。特别的，对于给定k个边框的每个边框，我们计算c类的分数和4个相对于原始默认框形状的偏移。在特征图的每个特征单元上需要有（c+4）x k个过滤器，对于m x n的特征图就会产生（c + 4） x k x m x n个输出。这里的默认框很类似于Faster R-CNN中的锚框，但是这里将他应用到不同解决方案的一些特征图中。在一些特征图中允许不同形状的默认框能偶有效的离散化可能的输出框形状的空间。\n\n![model](https://raw.githubusercontent.com/jChanJi/static_resource/master/SSD/model.PNG)\n","tags":["object detection"],"categories":["-artical"]},{"title":"知识图谱","url":"/year/11/19/knowledgegraph/","content":"\n# 知识图谱\n## 起源\n> &nbsp; &nbsp; &nbsp; &nbsp;知识图谱于2012年5月17日被Google正式提出， 其初衷是为了提高搜索引擎的能力，增强用户的搜索质量以及搜索体验。，RDF (resource description framework)<sup>[1]</sup>模式(RDF schema) （应用）和万维网本体语言(Web ontology language，OWL) 的形式化模型就是基于上述目的产生的。\n\n\n<!--more-->\n\n> [1]RDF: RDF是一个处理元数据的XML,RDF使用XML语法和RDF Schema（RDFS）来将元数据描述成为数据模型。是描述语义层面的本体关系的语言。\n\n>[2]数据模型: 数据模型（Data Model）是数据特征的抽象。数据（Data）是描述事物的符号记录，模型（Model)是现实世界的抽象。数据模型所描述的内容有三部分：数据结构、数据操作和数据约束。\n\n## 定义\n> &nbsp; &nbsp; &nbsp; &nbsp;知识图谱是Google用于增强其搜索引擎功能的知识库。本质上,知识图谱是一种揭示实体之间关系的 **语义网络（semantic network）** ,即具 有有向图结构的一个知识库，其中图的结点代 表实体（entity）或者概念（concept），而图的 边代表实体/ 概念之间的各种语义关系，可以对现实世界的事物及其相互关系进行形式化地描述。现在的知识图谱已被用来泛指各种大规模的知识库。\n\n![知识图谱](https://raw.githubusercontent.com/jChanJi/static_resource/master/knowledgegraph/knowledgegraph2.png)\n\n## 应用领域\n> &nbsp; &nbsp; &nbsp; &nbsp;广泛应用于智能搜索、 智能问答、个性化推荐等领域。尤其是在智能搜索中，用户的搜索请求不再局限于简单的关键词匹配，搜索将根据用户查询的情境与意图进行推理，实现 概念检索。与此同时，用户的搜索结果将具有层次 化、结构化等重要特征。\n\n## 分类\n> &nbsp; &nbsp; &nbsp; &nbsp;**知识图谱也可分为通用知识图谱(开放链接知识库)和行业知识图谱(垂直行业知识库)**。\n\n### 通用知识图谱\n> &nbsp; &nbsp; &nbsp; &nbsp;通用知识图谱注重广度，强调融合更多的实体，较行业知识图谱而言,其准确度不够高,并且受概念范围的影响,很难借助本体库对公理、规则以及约束条件的支持能力规范其实 体、属性、实体间的关系等。通用知识图谱主要应 用于智能搜索等领域。行业知识图谱通常需要依靠 特定行业的数据来构建，具有特定的行业意义。\n\n### 行业知识图谱\n> &nbsp; &nbsp; &nbsp; &nbsp;行业知识图谱中，实体的属性与数据模式往往比较丰富，需要考虑到不同的业务场景与使用人员。\n\n## 架构\n### 逻辑架构\n>  &nbsp; &nbsp; &nbsp; &nbsp;知识图谱在逻辑上可分为 **模式层** 与 **数据层** 两个层次.\n\n#### 1、数据层\n> &nbsp; &nbsp; &nbsp; &nbsp;数据层主要是由一系列的事实组成，而知识将以事实为单位进行存储。如果用(实体1，关系， 实体2)、(实体、属性，属性值)这样的三元组来表达事实,可选择 **图数据库** 作为存储介质。\n\n#### 2、模式层\n> &nbsp; &nbsp; &nbsp; &nbsp;模式层构建在数据层之上，主要是通过 **本体库** 来规范数据层的一系列事实表达。 **本体是结构化知识库的概念模板** ，通过本体库而形成的知识库不仅层次结构较强，并且冗余程度较小。\n\n### 体系结构（构建模式）\n> &nbsp; &nbsp; &nbsp; &nbsp;知识图谱的体系架构知识图谱的体系架构是其指构建模式结构，如图1所示。其中虚线框内的部分为知识图谱的构建过 程，该过程需要随人的认知能力不断更新迭代。知识图谱主要有 **自顶向下(top-down)** 与 **自底向上(bottom-up)** 两种构建方式。\n\n#### 自顶向上\n> 自顶向下指的是: **先为知识图谱定义好本体与数据模式，再将实体加入到知识库**。该构建方式需要利用一些现有的结构化知识库作为其基础知识库，例如Freebase项目就是采用这种方式，它的绝大部分数据是从维基百科中得到的。\n\n#### 自底向上\n> &nbsp; &nbsp; &nbsp; &nbsp;自底向上指的是 **从一些开放链接数据中提取出实体，选择其中置信度较高的加入到知识库，再构建顶层的本体模式** 。目前，大多数知识图谱都采用自底向上的方式进行构建，其中典型就是 Google的Knowledge Vault。\n\n![图1](https://raw.githubusercontent.com/jChanJi/static_resource/master/knowledgegraph/1.PNG)\n\n\n## 关键技术\n###  知识抽取\n#### 知识抽取\n##### 基于规则与词典的实体抽取方法\n> &nbsp; &nbsp; &nbsp; &nbsp;早期的实体抽取是在限定文本领域、限定语义 单元类型的条件下进行的，主要采用的是基于规则与词典的方法， **例如使用已定义的规则，抽取出文本中的人名、地名、组织机构名、特定时间等实体。**\n\n##### 基于统计机器学习的实体抽取方法\n> &nbsp; &nbsp; &nbsp; &nbsp;随后，研究者尝试将机器学习中的 **监督学习** 算法用于命名实体的抽取问题上。单纯的监督学习算法在性能上 不仅受到训练集合的限制，并且算法的准确率与召回率都不够理想。相关研究者认识到监督学习算法的制约性后，尝试将监督学习算法与规则相互结合。\n\n##### 面向开放域的实体抽取方法\n> &nbsp; &nbsp; &nbsp; &nbsp;其基本思想是通过 **少量的实体实例建立特征模型，再通过该模型应用于新的数据集得到新的命名实体**。基于 **无监督学习** 的开放域聚类算法，其基本思想是基于已知实体的语义特征去搜索日志中识别出命名的实体，然后进行聚类。\n\n#### 关系抽取\n> &nbsp; &nbsp; &nbsp; &nbsp;关系抽取的目标是解决实体间语义链接的问题。主要有效的方法是基于马尔可夫逻辑网和基于本体推理的深层隐含关系抽取方法，主要有一下俩个分类。\n\n##### 开放式实体关系抽取\n> &nbsp; &nbsp; &nbsp; &nbsp;开放式实体关系抽取可分为二元开放式关系抽 取和n元开放式关系抽取。\n\n##### 基于联合推理的实体关系抽取\n> &nbsp; &nbsp; &nbsp; &nbsp;联合推理的关系抽取中的典型方法是马尔可夫逻辑网MLN(Markov logic network)<sup>[1]</sup>。\n\n> [1] 马尔可夫逻辑网:\n\n###  属性抽取\n> &nbsp; &nbsp; &nbsp; &nbsp;属性抽取主要是针对实体而言的，通过属性可形成对实体的完整勾画。由于实体的属性可以看成是 **实体与属性值之间的一种名称性关系** ，因此可以将实体属性的抽取问题转换为关系抽取问题。\n\n> &nbsp; &nbsp; &nbsp; &nbsp;大量的属性数据主要存在于半结构化、非结构化的大规模开放域数据集中。抽取这些属性的方法，一种是将上述从百科网站上抽取的 **结构化数据作为可用于属性抽取的训练集，然后再将该模型应用于开放域中的实体属性抽取** 。另一种是 **根据实体属性与属性值之间的关系模式，直接从开放域数据集上抽取属性。**\n\n# 本体\n## 定义\n>  &nbsp; &nbsp; &nbsp; &nbsp;Gruber给出了Ontology的一个最为流行的定义,即“Ontology是概念模型<sup>[1]</sup> 的明确的规范说明”。\n\n> [1] 概念模型: “概念模型” 指通过抽象出客观世界中一些现象的相关概念而得到的模型。首先把现实世界中的客观对象抽象为某一种信息结构，这种信息结构并不依赖于具体的计算机系统，不是某一个数据库管理系统（DBMS）支持的 **数据模型** ，而是概念级的模型，称为概念模型。<br>\n\n> [2] 数据模型: 数据模型（Data Model）是数据特征的抽象。数据是描述事物的符号记录，模型是现实世界的抽象。数据模型为数据库系统的信息表示与操作提供了一个抽象的框架。数据模型所描述的内容有三部分：数据结构、数据操作和数据约束。\n\n## 举例解释\n> &nbsp; &nbsp; &nbsp; &nbsp;上面的概念很抽象，不是很好理解，其实本体的概念有两层意思，一层是哲学层面的意思，一层是引申到信息科学中的语义层面的意思。\n\n### 哲学上的本体\n> “鼠标”，“mouse”,\n\n![符号](https://raw.githubusercontent.com/jChanJi/static_resource/master/knowledgegraph/entity1.PNG)\n\n> &nbsp; &nbsp; &nbsp; &nbsp;等都是表示\"鼠标\"这个本体的的\"符号\"。由此可见“本体”是只可意会不可言传的，因为所有的描述都成为了“本体”的外在符号，我们世界上的所有图像、语言、我们看到的、听到的、感受到的，都成为符号到本体的某种映射。\n\n### 信息科学中的本体\n> &nbsp; &nbsp; &nbsp; &nbsp;Ontology是一种 **描述术语** （包含哪些词汇）及 **术语间关系** （描述苹果、香蕉、水果之间的关系）的概念模型。Ontology的形式可简单可复杂。最简单的词汇表（只定义术语集合，不定义术语之间的关系）也可以看成是一种“本体”；但严格意义上的本体，是既定义了术语、也定义了术语之间关系的。生活中，最常见、最成熟的本体，就属图书馆里的图书分类法。本体，以图书分类法为例，一方面限定了术语集合（即规定大家必须采用共同承认的一套词汇，禁止私自发明新词），另一方面定义术语之间的上下位关系（如：计算机技术隶属于工业技术，软件技术隶属于计算机技术，等等）。只要大家都认同该本体，并在实践中长期遵守该本体，依照它来编排和索引书目，那么日后寻找一本书就会非常方便。\n\n## 本体与知识图谱(语义网)的区别\n> 1、Ontology 是对共享概念模型的规范说明 ,这里所说的“共享概念模型” 指该模型中的 **概念是公认** 的 ,至少在某个特定的领域是公认的。一般情况下 ,Ontology 是 **面向特定领域**  , 用于描述特定领域的概念模型。<br>\n\n> 2、语义网络从数学上说 ,是一种带有标记的有向图。它最初用 于表示命题信息 ,现广泛应用于专家系统表示知识。语义网络中节点表示物理实体、概念或状态 ,连接节点的边用于表示关系。语义网络中对节点和边没有其他特殊的规定 ,因此 **语义网络描述的对象或范围比Ontology广。**\n\n\n引用<br>\n[1] 徐增林, 盛泳潘, 贺丽荣,等. 知识图谱技术综述[J]. 电子科技大学学报, 2016, 45(4):589-606.<br>\n[2] 漆桂林, 高桓, 吴天星. 知识图谱研究进展[J]. 情报工程, 2017, 3(1):4-25.<br>\n[3] 邓志鸿, 唐世渭, 张铭,等. Ontology研究综述[J]. 北京大学学报(自然科学版), 2002, 38(5):730-738.<br>\n[4]李国洪, 梁保城, 赵毅,等. Ontology研究的知识图谱演化[J]. 情报杂志, 2013(3):101-105.<br>\n[5] Gruber T R. A Translation Approach to Portable Ontology Specifications. Knowledge Acquisition ,1993 ,5 :199～220\n","categories":["-arcticals"]},{"title":"Arabesque:A System for Distributed Graph Mining","url":"/year/10/30/artical_1/","content":"\n## Arabesque: A System for Distributed Graph Mining\n> ### Arabesque:分布式的图挖掘系统\n\n\n#### 原文链接：[点我跳转](https://github.com/jChanJi/jchanji.github.com/blob/master/meterial/093-teixeira.pdf)\n\n## 目录\n\n* [Abstract](#Abstract)\n\n* 1.[Introduction](#introduction)\n\n<!--more-->\n\n* 2.Graph Mining Problems\n\n* 3.The Filter-Process Model\n\n    * 3.1.Computational Model\n\n    * 3.2.Alternative Paradigms: Think Like a Vertex and Think Like a Pattern\n\n* 4.Arabesque: API, Programming, and Implementation\n    * 4.1 Arabesque API\n\n    * 4.2 Programming with Arabesque\n\n    * 4.3 Arabesque implementation\n\n* 5.Graph Exploration Techniques\n    * 5.1 Coordination-Free Exploration Strategy\n\n    * 5.2 Storing Embeddings Compactly\n\n    * 5.3 Partitioning Embeddings for Load Balancing\n\n    * 5.4 Two-Level Pattern Aggregation for Fast Pattern Canonicality Checking\n* 6.Evaluation\n    * 6.1 Experimental Setup\n\n    * 6.2 Alternative Paradigms: TLV and TLP\n\n    * 6.3 Arabesque: The TLE Paradigm\n\n    * 6.4 Large Graphs with Arabesque\n\n* 7.Related Work\n\n* 8.Conclusions\n\n* 9.Acknowledgments\n\n* 10.References\n\n### <span id=\"Abstract\">Abstract</span>\n\n\n\n#### 原文\n\n#### Abstract\n  Distributed data processing platforms such as MapReduce\nand Pregel have substantially simplified the design and deployment\nof certain classes of distributed graph analytics algorithms.\nHowever, these platforms do not represent a good\nmatch for distributed graph mining problems, as for example\nfinding frequent subgraphs in a graph. Given an input\ngraph, these problems require exploring a very large number\nof subgraphs and finding patterns that match some “interestingness”\ncriteria desired by the user. These algorithms are\nvery important for areas such as social networks, semantic\nweb, and bioinformatics.\n\n  In this paper, we present Arabesque, the first distributed\ndata processing platform for implementing graph mining\nalgorithms. Arabesque automates the process of exploring\na very large number of subgraphs. It defines a high-level\nfilter-process computational model that simplifies the development\nof scalable graph mining algorithms: Arabesque explores\nsubgraphs and passes them to the application, which\nmust simply compute outputs and decide whether the subgraph\nshould be further extended. We use Arabesque’s API\nto produce distributed solutions to three fundamental graph\nmining problems: frequent subgraph mining, counting motifs,\nand finding cliques. Our implementations require a\nhandful of lines of code, scale to trillions of subgraphs, and\nrepresent in some cases the first available distributed solutions.\n\n#### 翻译\n  Distributed data processing platforms such as MapReduce\nand Pregel have substantially simpliﬁed the design and deployment of certain classes of distributed graph analyticsal gorithms.\n\n>分布式数据处理平台例如mapreduce和pregel实质上是简化了某些类的分布式图形化分析算法的设计和调度\n\n However, these platforms do not represent a good\nmatch for distributed graph mining problems, as for example\nfinding frequent subgraphs in a graph.\n\n>但是，这些平台没有表现出对分布式图形挖掘问题的匹配。就以在图表中频繁的寻找子图作为例子\n\nGiven an input graph, these problems require exploring a very large number of subgraphs and finding patterns that match some “interestingness” criteria desired by the user.\n\n>给出一个输入图表，这些问题需要扫描（探索）一个数量很多的子图并且寻找和用户期望的一些\"兴趣性\"准则相匹配的模式（图案,样品）。\n\nThese algorithms are very important for areas such as social networks, semantic web, and bioinformatics.\n\n\n>这些算法对例如社交网络，语义网，和分析复杂生物的学科的领域非常重要。\n\n\nIn this paper, we present Arabesque, the first distributed\ndata processing platform for implementing graph mining\nalgorithms.\nArabesque automates the process of exploring a very large number of subgraphs.\n\n>在这篇文献当中，我们介绍Arabesque,第一个实现图挖掘算法的分布式数据处理平台。Arabesque自动化了探索一个很大数量的子图的流程。\n\nIt defines a high-level filter-process computational model that simplifies the development of scalable graph mining algorithms: Arabesque explores subgraphs and passes them to the application, which must simply compute outputs and decide whether the subgraph should be further extended.\n\n>他定义了一个高级的过滤过程的计算模型，它简化了可升级的图挖掘算法的开发:Arabesque 探索子图并且将他们传递给应用程序，这个应用程序必须简单的计算输出和决定是否子图应该被进一步的被扩展。\n\nWe use Arabesque’s API to produce distributed solutions to three fundamental graph mining problems: frequent subgraph mining, counting motifs,and finding cliques.\n\n>我们用Arabesque的API去产生三个基础的图挖掘问题的分布式解决方案:频繁的子图挖掘，计数的图案，寻找派系。\n\nOur implementations require a handful of lines of code, scale to trillions of subgraphs, and represent in some cases the first available distributed solutions.\n\n>我们的实现需要很少行的代码，规模数万亿的子图，和在某些情况下第一个可获得的分布式解决方案的示范\n\n\n#### 段落翻译\n#### 摘要\n分布式数据处理平台例如mapreduce和pregel实质上是简化了某些类的分布式图形化分析算法的设计和调度.但是，这些平台没有表现出对分布式图形挖掘问题的匹配。就以在图表中频繁的寻找子图作为例子.给出一个输入图表，这些问题需要扫描（探索）一个数量很多的子图并且寻找和用户期望的一些\"兴趣性\"准则相匹配的模式（图案,样品）。这些算法对例如社交网络，语义网，和分析复杂生物的学科的领域非常重要。\n\n在这篇文献当中，我们介绍Arabesque,第一个实现图挖掘算法的分布式数据处理平台。Arabesque自动化了探索一个很大数量的子图的流程。他定义了一个高级的过滤过程的计算模型，它简化了可升级的图挖掘算法的开发:Arabesque 探索子图并且将他们传递给应用程序，这个应用程序必须简单的计算输出和决定是否子图应该被进一步的被扩展.我们用Arabesque的API去产生三个基础的图挖掘问题的分布式解决方案:频繁的子图挖掘，计数的图案，寻找派系。我们的实现需要很少行的代码，规模数万亿的子图，和在某些情况下第一个可获得的分布式解决方案的示范\n\n\n\n### <span id=\"Introduction\">Introduction</span>\n\n### 原文\n\nGraph data is ubiquitous in many fields, from the Web to advertising\nand biology, and the analysis of graphs is becoming\nincreasingly important. The development of algorithms\nfor graph analytics has spawned a large amount of research,\nespecially in recent years. However, graph analytics has traditionally\nbeen a challenging problem tackled by expert researchers,\nwho can either design new specialized algorithms\nfor the problem at hand, or pick an appropriate and sound\nsolution from a very vast literature. When the input graph or\nthe intermediate state or computation complexity becomes\nvery large, scalability is an additional challenge.\n\nThe development of graph processing systems such as\nPregel [25] has changed this scenario and made it simpler to\ndesign scalable graph analytics algorithms. Pregel offers a\nsimple “think like a vertex” (TLV) programming paradigm,\nwhere each vertex of the input graph is a processing element\nholding local state and communicating with its neighbors\nin the graph. TLV is a perfect match for problems that\ncan be represented through linear algebra, where the graph\nis modeled as an adjacency matrix (or some other variant\nlike the Laplacian matrix) and the current state of each vertex\nis represented as a vector. We call this class of methods\ngraph computation problems. A good example is computing\nPageRank [6], which is based on iterative sparse matrix\nand vector multiplication operations. TLV covers several\nother algorithms that require a similar computational architecture,\nfor example, shortest path algorithms, and over the\nyears many optimizations of this paradigm have been proposed\n[17, 26, 36, 42].\n\nDespite this progress, there remains an important class\nof algorithms that cannot be readily formulated using the\nTLV paradigm. These are graph mining algorithms used\nto discover relevant patterns that comprise both structurebased\nand label-based properties of the graph. Graph mining\nis widely used for several applications, for example, discovering\n3D motifs in protein structures or chemical compounds,\nextracting network motifs or significant subgraphs\nfrom protein-protein or gene interaction networks, mining\nattributed patterns over semantic data (e.g., in Resource\nDescription Framework or RDF format), finding structurecontent\nrelationships in social media data, dense subgraph mining for community and link spam detection in web data,among others. Graph mining algorithms typically take a labeled and immutable graph as input, and mine patterns\nthat have some algorithm-specific property (e.g., frequency\nabove some threshold) by finding all instances of these patterns\nin the input graph. Some algorithms also compute aggregated\nmetrics based on these subgraphs\n\n\n![图1](./img/1.PNG)\n\nFigure 1: Exponential growth of the intermediate state in\ngraph mining problems (motifs counting, clique finding,\nFSM: Frequent subgraph mining) on different datasets.\n\n\nDesigning graph mining algorithms is a challenging and\nactive area of research. In particular, scaling graph mining\nalgorithms to even moderately large graphs is hard. The set\nof possible patterns and their subgraphs in a graph can be\nexponential in the size of the original graph, resulting in an\nexplosion of the computation and intermediate state. Figure\n1 shows the exponential growth of the number of “interesting”\nsubgraphs of different sizes in some of the graph\nmining problems and datasets we will evaluate in this paper.\nEven graphs with few thousands of edges can quickly generate\nhundreds of millions of interesting subgraphs. The need\nfor enumerating a large number of subgraphs characterizes\ngraph mining problems and distinguishes them from graph\ncomputation problems. Despite this state explosion problem,\nmost graph mining algorithms are centralized because of the\ncomplexity of distributed solutions.\n\n\nIn this paper, we propose automatic subgraph exploration\nas a generic building block for solving graph mining\nproblems, and introduce Arabesque, the first embedding exploration\nsystem specifically designed for distributed graph\nmining. Conceptually, we move from TLV to “think like an\nembedding” (TLE), where by embedding we denote a subgraph\nrepresenting a particular instance of a more general\ntemplate subgraph called a pattern (see Figure 2).\n\n\nArabesque defines a high-level filter-process computational\nmodel. Given an input graph, the system takes care\nof automatically and systematically visiting all the embeddings\nthat need to be explored by the user-defined algorithm,\nperforming this exploration in a distributed manner. The system\npasses all the embeddings it explores to the application,\nwhich consists primarily of two functions: filter, which indicates whether an embedding should be processed, and process,\nwhich examines an embedding and may produce some\noutput. For example, in the case of finding cliques the filter\nfunction prunes embeddings that are not cliques, since none\nof their extensions can be cliques, and the process function\noutputs all explored embeddings, which are cliques by construction.\nArabesque also supports the pruning of the exploration\nspace based on user-defined metrics aggregated across\nmultiple embeddings.\n\n![图2](./img/2.PNG)\n\n\nFigure 2: Graph mining concepts: an input graph, an example\npattern, and the embeddings of the pattern. Colors represent\nlabels. Numbers denote vertex ids. Patterns and embeddings\nare two types of subgraphs. However, a pattern is\na template, whereas an embedding is an instance. In this example,\nthe two embeddings are automorphic.\n\nThe Arabesque API simplifies and thus democratizes the\ndesign of graph mining algorithms, and automates their execution\nin a distributed setting. We used Arabesque to implement\nand evaluate scalable solutions to three fundamental\nand diverse graph mining problems: frequent subgraph mining,\ncounting motifs, and finding cliques. These problems\nare defined precisely in Section 2. Some of these algorithms\nare the first distributed solutions available in the literature,\nwhich shows the simplicity and generality of Arabesque.\n\nArabesque’s embedding-centered API facilitates a highly\nscalable implementation. The system scales by spreading\nembeddings uniformly across workers, thus avoiding\nhotspots. By making it explicit that embeddings are the fundamental\nunit of exploration, Arabesque is able to use fast\ncoordination-free techniques, based on the notion of embedding\ncanonicality, to avoid redundant work and minimize\ncommunication costs. It also enables us to store embeddings\nefficiently using a new data structure called Overapproximating\nDirected Acyclic Graph (ODAG), and to devise a\nnew two-level optimization for pattern-based aggregation,\nwhich is a common operation in graph mining algorithms.\n\n\nArabesque is implemented as a layer on top of Apache\nGiraph [3], a Pregel-inspired graph computation system,\nthus allowing both graph computation and graph mining\nalgorithms to run on top of the same infrastructure. The\nimplementation does not use a TLV approach: it considers\nGiraph just as a regular data parallel system implementing\nthe Bulk Synchronous Processing model.\nTo summarize, we make the following contributions:\n\n• We propose embedding exploration, or “think like an embedding”,\nas an effective basic building block for graph\nmining. We introduce the filter-process computational\nmodel (Section 3), design an API that enables embedding\nexploration to be expressed effectively and succinctly,\nand present three example graph mining applications\nthat can be elegantly expressed using the Arabesque\nAPI (Section 4).\n\n• We introduce techniques to make distributed embedding\nexploration scalable: coordination-free work sharing, ef-\nficient storage of embeddings, and an important optimization\nfor pattern-based aggregation (Section 5).\n\n• We demonstrate the scalability of Arabesque on various\ngraphs. We show that Arabesque scales to hundreds of\ncores over a cluster, obtaining orders of magnitude reduction\nof running time over the centralized baselines (Section\n6), and can analyze trillions of embeddings on large\ngraphs.\n\nThe Arabesque system, together with all applications\nused for this paper, is publicly available at the project’s website:\nwww.arabesque.io.\n\n#### 翻译\n\nGraph data is ubiquitous in many fields, from the Web to advertising and biology, and the analysis of graphs is becoming increasingly important.\n\n>图形数据在许多领域普遍存在，从网站到广告业和生物学，并且分析图形正在变得越来越重要。\n\nThe development of algorithms for graph analytics has spawned a large amount of research, especially in recent years.\n\n>图形分析算法的发展催生了大量的研究，尤其是在近些年来。\n\nHowever, graph analytics has traditionally been a challenging problem tackled by expert researchers, who can either design new specialized algorithms for the problem at hand, or pick an appropriate and sound solution from a very vast literature.\n\n>但是，图形分析历年来是具有挑战性的，由那些能够为了手上的问题设计新的专门的算法或者从非常庞大的文献中选择一个适当并且健全的解决方案的专家去解决。\n\nWhen the input graph or the intermediate state or computation complexity becomes very large, scalability is an additional challenge.\n\n>当输入图形或者中间状态或者计算复杂度非常大的时候，可测量性是一额外的挑战。\n\nThe development of graph processing systems such as Pregel [25] has changed this scenario and made it simpler to design scalable graph analytics algorithms.\n\n>图形处理系统的发展例如pregel改变了这种方案，并且使设计可升级的图形分析算法更加的简单。\n\nPregel offers a simple “think like a vertex” (TLV) programming paradigm, where each vertex of the input graph is a processing element holding local state and communicating with its neighbors in the graph.\n\n>Pregel 提供了一个简单的\"像顶点一样思考\"的编程范例，每一个输入图的顶点是一个保持局部状态的处理单元并且在图形中和它的邻点进行通讯。\n\nTLV is a perfect match for problems that can be represented through linear algebra, where the graph is modeled as an adjacency matrix (or some other variant like the Laplacian matrix) and the current state of each vertex is represented as a vector.\n\n>T L V 对那些通过线性代数表示的问题能够完美的匹配，在那些图形建模为邻接矩阵（或者一些其他变形像路普拉斯矩阵）和每一个顶点的当前状态被表示为一个向量的问题中。\n\nWe call this class of methods graph computation problems.\n\n>我们称这一类的方法叫做图计算问题\n\nA good example is computing PageRank [6], which is based on iterative sparse matrix and vector multiplication operations.\n\n>一个好的例子就是计算PageRank, 它是基于迭代稀疏矩阵和向量乘法运算。\n\nTLV covers several other algorithms that require a similar computational architecture, for example, shortest path algorithms, and over the years many optimizations of this paradigm have been proposed [17, 26, 36, 42].\n\n>TLV 涉及了一些其他的算法，它需要相似的计算结构，例如，最短路径算法，多年来，这种模式的许多优化已被提出来。\n\nDespite this progress, there remains an important class of algorithms that cannot be readily formulated using the TLV paradigm.\n\n>尽管这些进展，这里依然有一类重要的算法不可以使用TLV范例制定。\n\nThese are graph mining algorithms used to discover relevant patterns that comprise both structurebased and label-based properties of the graph.\n\n>这些就是用于发现相关模式的基于结构和基于表的图的性质的图挖掘算法。\n\n\n Graph mining is widely used for several applications, for example, discovering 3D motifs in protein structures or chemical compounds, extracting network motifs or significant subgraphs from protein-protein or gene interaction networks, mining attributed patterns over semantic data (e.g., in Resource Description Framework or RDF format), finding structure content relationships in social media data, dense subgraph mining for community and link spam detection in web data,among others.\n\n>图挖掘广泛的用于一些应用，例如发现蛋白质结构中或者化学物质中的3D图案，从蛋白质或者基因交互网络中提取网络图案或者重要的子图，(例如在资源描述框架或者R D F 格式中)，正在使用发音在社会媒体数据，密集的子图挖掘社区和链接的垃圾邮件检测在Web数据中发现结构内容的关系，等等。\n\n Graph mining algorithms typically take a labeled and immutable graph as input, and mine patterns that have some algorithm-specific property (e.g., frequency above some threshold) by finding all instances of these patterns\nin the input graph.\n\n\n>图形挖掘算法通常采用一个标记和不可变的图形作为输入,和具有一些算法特性的挖掘模式（例如频率高于某个阈值），通过在输入图中的样式的所有实例。\n\nSome algorithms also compute aggregated metrics based on these subgraphs。\n一些算法也计算基于这些子图的综合指标。\n\n\nFigure 1: Exponential growth of the intermediate state in\ngraph mining problems (motifs counting, clique finding,\nFSM: Frequent subgraph mining) on different datasets.\n\n>图一：在不同的数据集中图挖掘问题中的中间状态的指数增长（图案计数，派系的发现，频繁子图挖掘）\n\nDesigning graph mining algorithms is a challenging and\nactive area of research.\n\n>设计图挖掘算法在研究中是一个具有挑战性和活跃的领域\n\n\nIn particular, scaling graph mining\nalgorithms to even moderately large graphs is hard.\n\n>尤其是，将图挖掘算法应用于中等大小的图是困难的\n\nThe set of possible patterns and their subgraphs in a graph can be\nexponential in the size of the original graph, resulting in an\nexplosion of the computation and intermediate state.\n\n>图表中的可能的模式集和他们的子图有可能是原始图大小的指数倍，导致了爆炸性的计算和中间状态。\n\nFigure 1 shows the exponential growth of the number of “interesting”\nsubgraphs of different sizes in some of the graph\nmining problems and datasets we will evaluate in this paper.\n\n>图一展示在一些图挖掘问题中不同大小的“intersting”子图的数量的爆炸性增长并且我们将评估文本的数据集。\n\nEven graphs with few thousands of edges can quickly generate\nhundreds of millions of interesting subgraphs.\n\n>即使是数千个边的图也能生成数亿的\"intersting\"子图。\n\nThe need for enumerating a large number of subgraphs characterizes\ngraph mining problems and distinguishes them from graph\ncomputation problems.\n\n>图挖掘问题以需要枚举很大数量的子图为特征并且将其于图计算问题区别开来。\n\n Despite this state explosion problem,\nmost graph mining algorithms are centralized because of the\ncomplexity of distributed solutions.\n\n>尽管这个状态是爆炸性的问题，但是大多数图形挖掘算法是集中式的，因为\n分布式解决方案的复杂性。\n\n\nIn this paper, we propose automatic subgraph exploration\nas a generic building block for solving graph mining\nproblems, and introduce Arabesque, the first embedding exploration\nsystem specifically designed for distributed graph\nmining.\n\n>在这篇文章中，我们把自动子图搜索看作是一个解决图挖掘问题的通用构建，并且介绍阿拉伯图案\n，它是第一个为分布式图挖掘设计的嵌入式的探索系统\n\nConceptually, we move from TLV to “think like an\nembedding” (TLE), where by embedding we denote a subgraph\nrepresenting a particular instance of a more general\ntemplate subgraph called a pattern (see Figure 2).\n\n>从概念上讲，我们从TLV移动到了“像嵌入一样思考”（TLE）,通过嵌入，我们表示一个子图\n通过表示一个称之为模式的更一般的模板的特别的实例（看图二）\n\nArabesque defines a high-level filter-process computational\nmodel.\n\n>阿拉伯图案定义了一个高层次的过滤过程计算模型。\n\nGiven an input graph, the system takes care\nof automatically and systematically visiting all the embeddings\nthat need to be explored by the user-defined algorithm,\nperforming this exploration in a distributed manner.\n\n>给出一个输入图，系统会自动的，系统性的关注访问所有的那些需要通过通过分布式的方式进行的自定义算法探索的嵌入部分。\n\nThe system passes all the embeddings it explores to the application,\nwhich consists primarily of two functions: filter, which indicates whether an embedding should be processed, and process,which examines an embedding and may produce some output.\n\n>系统通过所有的嵌入部分并暴露给应用，应用主要由两个函数组成：过滤器，指示是否嵌入部分应该被处理。处理，审查一个嵌入部分和有可能处理一些输出。\n\nFor example, in the case of finding cliques the filter function prunes embeddings that are not cliques, since none of their extensions can be cliques, and the process function outputs all explored embeddings, which are cliques by construction.\n\n>例如，在发现子图派系的案例中过滤器的功能用于修剪不是派系的嵌入部分，因为他们的拓展没有可能是派系，并且处理函数输出所有探索的嵌入部分，那些嵌入的部分通过建设而形成派系。\n\nArabesque also supports the pruning of the exploration\nspace based on user-defined metrics aggregated across multiple embeddings.\n\n>Arabesque还支持修剪基于用户定义的度量标准聚合的空间多次嵌入的探测。\n\nFigure 2: Graph mining concepts: an input graph, an example\npattern, and the embeddings of the pattern. Colors represent\nlabels. Numbers denote vertex ids. Patterns and embeddings\nare two types of subgraphs. However, a pattern is\na template, whereas an embedding is an instance. In this example,\nthe two embeddings are automorphic.\n\n>图二：\n\nThe Arabesque API simplifies and thus democratizes the\ndesign of graph mining algorithms, and automates their execution\nin a distributed setting. We used Arabesque to implement\nand evaluate scalable solutions to three fundamental\nand diverse graph mining problems: frequent subgraph mining,\ncounting motifs, and finding cliques. These problems\nare defined precisely in Section 2. Some of these algorithms\nare the first distributed solutions available in the literature,\nwhich shows the simplicity and generality of Arabesque.\n\nArabesque’s embedding-centered API facilitates a highly\nscalable implementation. The system scales by spreading\nembeddings uniformly across workers, thus avoiding\nhotspots. By making it explicit that embeddings are the fundamental\nunit of exploration, Arabesque is able to use fast\ncoordination-free techniques, based on the notion of embedding\ncanonicality, to avoid redundant work and minimize\ncommunication costs. It also enables us to store embeddings\nefficiently using a new data structure called Overapproximating\nDirected Acyclic Graph (ODAG), and to devise a\nnew two-level optimization for pattern-based aggregation,\nwhich is a common operation in graph mining algorithms.\n\n\nArabesque is implemented as a layer on top of Apache\nGiraph [3], a Pregel-inspired graph computation system,\nthus allowing both graph computation and graph mining\nalgorithms to run on top of the same infrastructure. The\nimplementation does not use a TLV approach: it considers\nGiraph just as a regular data parallel system implementing\nthe Bulk Synchronous Processing model.\nTo summarize, we make the following contributions:\n\n• We propose embedding exploration, or “think like an embedding”,\nas an effective basic building block for graph\nmining. We introduce the filter-process computational\nmodel (Section 3), design an API that enables embedding\nexploration to be expressed effectively and succinctly,\nand present three example graph mining applications\nthat can be elegantly expressed using the Arabesque\nAPI (Section 4).\n\n• We introduce techniques to make distributed embedding\nexploration scalable: coordination-free work sharing, ef-\nficient storage of embeddings, and an important optimization\nfor pattern-based aggregation (Section 5).\n\n• We demonstrate the scalability of Arabesque on various\ngraphs. We show that Arabesque scales to hundreds of\ncores over a cluster, obtaining orders of magnitude reduction\nof running time over the centralized baselines (Section\n6), and can analyze trillions of embeddings on large\ngraphs.\n\nThe Arabesque system, together with all applications\nused for this paper, is publicly available at the project’s website:\nwww.arabesque.io.\n\n\n#### 段落翻译\n\n图形数据在许多领域普遍存在，从网站到广告业和生物学，并且分析图形正在变得越来越重要。\n图形分析算法的发展催生了大量的研究，尤其是在近些年来。但是，图形分析历年来是具有挑战性的，由那些能够为了手上的问题设计新的专门的算法或者从非常庞大的文献中选择一个适当并且健全的解决方案的专家去解决。当输入图形或者中间状态或者计算复杂度非常大的时候，可测量性是一额外的挑战。\n\n\n图形处理系统的发展例如pregel 改变了这种方案，并且使设计可升级的图形分析算法更加的简单。\nPregel 提供了一个简单的\"像顶点一样思考\"的编程范例，每一个输入图的顶点是一个保持局部状态的处理单元并且在图形中和它的邻点进行通讯。T L V 对那些通过线性代数表示的问题能够完美的匹配，在那些图形建模为邻接矩阵（或者一些其他变形像路普拉斯矩阵）和每一个顶点的当前状态被表示为一个向量的问题中。我们称这一类的方法叫做图计算问题一个好的例子就是计算PageRank, 它是基于迭代稀疏矩阵和向量乘法运算。TLV 涉及了一些其他的算法，它需要相似的计算结构，例如，最短路径算法，多年来，这种模式的许多优化已被提出来。\n\n尽管这些进展，这里依然有一类重要的算法不可以使用TLV范例制定。这些就是用于发现相关模式的基于结构和基于表的图的性质的图挖掘算法.图挖掘广泛的用于一些应用，例如发现蛋白质结构中或者化学物质中的3D图案，从蛋白质或者基因交互网络中提取网络图案或者重要的子图，(例如在资源描述框架或者R D F 格式中)，正在使用发音在社会媒体数据，密集的子图挖掘社区和链接的垃圾邮件检测在Web数据中发现结构内容的关系，等等。图形挖掘算法通常采用一个标记和不可变的图形作为输入,和具有一些算法特性的挖掘模式（例如频率高于某个阈值），通过在输入图中的样式的所有实例。一些算法也计算基于这些子图的综合指标。\n\n![图1](./img/1.PNG)\n\n图一：在不同的数据集中图挖掘问题中的中间状态的指数增长（图案计数，派系的发现，频繁子图挖掘）\n\n设计图挖掘算法在研究中是一个具有挑战性和活跃的领域。尤其是，将图挖掘算法应用于中等大小的图是很困难的。图表中的可能的模式集和他们的子图有可能是原始图大小的指数倍，导致了爆炸性的计算和中间状态。图一展示在一些图挖掘问题中不同大小的“intersting”子图的数量的爆炸性增长并且我们将评估文本的数据集。即使是数千个边的图也能生成数亿的\"intersting\"子图。图挖掘问题以需要枚举很大数量的子图为特征并且将其于图计算问题区别开来。尽管这个状态是爆炸性的问题，但是大多数图形挖掘算法是集中式的，因为分布式解决方案的复杂性。\n\n在这篇文章中，我们把自动子图搜索看作是一个解决图挖掘问题的通用构建，并且介绍阿拉伯图案\n，它是第一个为分布式图挖掘设计的嵌入式的探索系统。从概念上讲，我们从TLV移动到了“像嵌入一样思考”（TLE）,通过嵌入，我们表示一个子图通过表示一个称之为模式的更一般的模板的特别的实例（看图二）。阿拉伯图案定义了一个高层次的过滤过程计算模型。给出一个输入图，系统会自动的，系统性的关注访问所有的那些需要通过通过分布式的方式进行的自定义算法探索的嵌入部分。系统通过所有的嵌入部分并暴露给应用，应用主要由两个函数组成：过滤器，指示是否嵌入部分应该被处理。处理，审查一个嵌入部分和有可能处理一些输出。例如，在发现子图派系的案例中过滤器的功能用于修剪不是派系的嵌入部分，因为他们的拓展没有可能是派系，并且处理函数输出所有探索的嵌入部分，那些嵌入的部分通过建设而形成派系。\n\n![图2](./img/2.PNG)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[1]: https://jchanji.github.io \"主页\"\n","tags":["distribute system"],"categories":["-arcticals"]},{"title":"ubuntu只显示桌面，没有菜单栏","url":"/year/09/03/ubuntu_only_background/","content":"## 前言\n>在裝輸入法的時候好像刪了什麼東西導致電腦重啓的時候只能顯示桌面背景和文件，導航等都沒了，頓時嚇壞我了，找了好多教程終於成功了。\n\n<!--more-->\n\n##安裝unity\n```markdown\nsudo apt-get install unity\n```\n##刪除配置文件\n```markdown\nsudo rm -rf .conf\nsudo rm -rf .gconfg\nsudo rm -rf ~/.Xauthority\nreboot\n```\n本教程不一定對其他情況也適合\n","tags":["-ubuntu"],"categories":["-others"]},{"title":"伪分布式spark安装配置","url":"/year/09/03/spark_step/","content":"\n\n## 前言\n>本教程为spark的伪分布式教程，学生党条件有限所以伪分布式应该是比较好的选择。其中要注意的是版本匹配的问题。\n\n<!--more-->\n\n## 一、版本\n1. CentOS7\n2. jdk:jdk1.8.0_131\n2. hadoop：2.6.0\n3. scala:2.11.11\n4. spark:2.1.1\n\n## 二、下载\n1. [spark2.1.1](http://spark.apache.org/downloads.html)\n2. [scala2.11.11](http://www.scala-lang.org/download/all.html)\n\n## 三、安装配置\n\n### 1、解压,修改权限\n```markdown\nsudo tar -zxvf spark-2.1.1-bin-hadoop2.6.tgz -C /usr/local\ncd /usr/local\nsudo chown -R hadoop:hadoop ./spark\n```\n### 2、在解压的spark目录下新建文件/test/hellospark,写上内容\n\n### 3、进入scala模式\n\n```markdown\n   cd /spark/bin\n   ./spark-shell\n```\n\n### 4、运行代码\n\n```markdown\n5、val lines = sc.textFile(“../test/hellospark”)\n   lines.count()\n   lines.first()\n```\n\n### 5、修日志级别\n```markdown\n   cd /usr/local/spark/conf\n   cp  log4j.properties.template  log4j.properties   \n   sudo vim log4j.properties\n```\n   将其中的rootCategory=INFO 改为 WARN\n","tags":["spark"],"categories":["-bigdata"]},{"title":"sumlime text3 配置Markdown","url":"/year/09/03/markdown/","content":"## 一、sumlime text3 配置Markdown和常用快捷键\n### 1、sumlime text3 配置Markdown\n>#### 1、安装package Control<br>\n\n>#### 2、安装Markdown Preview<br>\n>&ensp; 2.1、 按Shif + Alt + P打开<br>\n>&ensp; 2.2、输入pcip,回车（进入install package）<br>\n\n<!--more-->\n\n>#### 3、安装Markdown  Editing<br>\n>&ensp;3.1、进入 install package<br>\n>&ensp;3.2、输入 Markdown Editing // Markdown编辑和语法高亮支持<br>\n\n>#### 4、安装Markdown  Previewer<br>\n>&ensp; 4.1、进入 install package<br>\n>&ensp; 4.2、Markdown  Previewer  //Markdown导出html预览支持<br>\n\n>#### 5、安装OmniMarkup Previewer<br>\n>&ensp; 5.1、进入 install package<br>\n>&ensp; 5.2、OmniMarkup Previewer //在浏览器中实时预览\n\n### 2、常用快捷键\n> 1. Ctrl + Alt + O //在浏览器中打开\n> 2. Alt + M  //生成html文件\n> 3. Ctrl+Alt+O: Preview Markup in Browser.\n> 4. Ctrl+Alt+X: Export Markup as HTML.\n> 5. Ctrl+Alt+C: Copy Markup as HTML.\n\n## 二、使用Cmd markdown在线编辑\n> 1. 在线[编辑] [1] 网址\n> 2. 也可以下载客户端离线编辑[客户端] [2]\n> 3. 如果想转成html等其他功能需要付费，不过基础功能已经差不多够用了\n\n\n## 遇到的问题\n\n### 1、Ctrl+Alt+O后打开了浏览器但是不能够预览ｍａｒｋｄｏｗｎ页面\n\n```markdown\n    在 Preferences > Package Settings > OmniMarkupPreviewer > Settings - User 中粘贴以下代码即可\n\n    {\n    \"renderer_options-MarkdownRenderer\": {\n        \"extensions\": [\"tables\", \"fenced_code\", \"codehilite\"]\n    }\n    }\n```\n\n### 2、在sublime text3 中切换不了中文\n```markdown\nsudo apt-get update && sudo apt-get upgrade\ngit clone https://github.com/lyfeyaj/sublime-text-imfix.git\ncd ~/sublime-text-imfix\nsudo ./ sublime-imfix\n然后重启sublime text3\n```\n\n\n[1]: https://www.zybuluo.com/mdeditor \"Cmd Markdown\"\n[2]: https://www.zybuluo.com/cmd/ \"下载\"\n\n","tags":["markdown"],"categories":["-others"]},{"title":"从互联到新工业革命-读后感","url":"/year/09/03/internet_of_everthing_for_new_industrial_revolution/","content":"\n## 目录\n### [一、工业4.0\"网红\"的养成之路](#one)\n### [二、\"工业互联网\" VS \"工业4.0\"](#two)\n### [三、中国制造2025](#three)\n### [四、工业革命升级技能点](#forth)\n### [五、人工智能](#firth)\n### [六、工业互联网的智能网络](#six)\n### [七、结束语](#end)\n## 前言\n>&nbsp;&nbsp;&nbsp;&nbsp;有幸能够参加东华大学计算机科学与技术学院举办的“大数据与智能制造”暑期夏令营。虽然只有短短的两天时间，但是收获颇多，尤其是听了燕山大学机械学院院长张立杰教授“智能制造和传统制造”的演讲和美国佛罗里达大学教授李晓林教授“Creating Intellignece via big learning”的演讲，对智能制造和人工智能领域了更加深刻的印象。由于我比较愚钝，具体的演讲内容不能详细的复述出来。再次由衷的感谢东华大学的常珊老师免费提供给我们《从互联到新工业革命》这本书，今天在火车上读完了这本通俗易懂而又见解深刻的书,无意发现,张立杰教授，李晓林教授，刘云浩教授，在智能制造方面的见解英雄所见略同，而为了更加体系的介绍和便于自己思路的清理，下面更多介绍清华大学软件学院院长刘云浩教授对互联网时代和新工业革命大潮的理解和体会并且再加上一点我个人的浅陋的见解。 由于本人文采有限，不能够很全面的写出刘老师书中的方方面面也无法用诙谐的语句吸引读者兴趣，所以我极力推荐大家读一读刘云浩老师的作品《从互联到新工业革命》（清华大学出版社）。由于我也只是泛读了一遍,所以写博客的时候也是第二次更加粗略的阅读，当中有什么见解不到的地方欢迎联系我（邮箱见文章底部）。\n\n<!--more-->\n\n## 导言\n>&nbsp;&nbsp;&nbsp;&nbsp;由于我也是刚接触大数据，人工智能不久，虽然对其中的技术细节还不是非常的了解，但引用刘国华教授\"纸上谈兵\"的观点，如果不去\"纸上谈兵\"而直接去埋头编程那么有可能永远都完成不了项目，或者当中算法效率是很低的。同样我觉得，学习一个完全陌生的专业，如果连它的发展趋势和技术线路都没有搞清楚的话，那么也只是一头雾水的填鸭式的学习,不利于以后潜力的挖掘和能力的提升。下面我们就\"空谈\"一些对技术能力提高\"无用\"的，空泛的，所谓\"夸夸而谈\"的观点。\n\n## <span id=\"one\"> 一、工业4.0\"网红\"的养成之路</span>\n>&nbsp;&nbsp;&nbsp;&nbsp;目前为止确切的有三次工业革命：1769年瓦特发明蒸汽机，标志着机械化的时代到来,机器代替了人类一部分的体力活动，人类向机械化迈进;1869年，德国西门子公司发明了第一台交流发动机，电器取代了机器，电器动力取代了蒸汽动力，从此促进了大规模，批量化的生产。也是从此时开始，东方开始落后西方；1969年，第一块可编程逻辑控制器Modicon 084问世，这标志这电子信息技术的发明并且直接导致了产品生产的高度自动化。此外还有一件划时代的事发生了，便是阿帕网的形成，也就是互联网的雏形。\n\n>&nbsp;&nbsp;&nbsp;&nbsp;近两百年之前的工业革命，在之后的150年里使西方人均收入增长了13倍，而1800年以前，西方人均经济翻一倍则需要800年。这足以见得这几次工业革命对人类社会生产力的解放是多么的恐怖，这也预示着，人类社会的发展速度将会越来越快。那么第四次工业革命会是在2069年吗？显然，就目前的形式来看完全等不到2069年。新工业革命已经隐约到来，虽然我们不能够从未来的角度来看现在来，判定是否是第四次工业革命，就像前三次工业革命一样，发生之后才意识具有多么伟大的意义，但是，我们已经确切的感受到新工业革命了。\"人类第一次成功的在事前预测了一次革命，而不是像以前一样事后才认识到是一场革命\",正如刘老师所言。\"工业4.0\"\n由孔翰宁(Henning Kagermann),沃夫冈.瓦尔斯特(\"Wolfgang Wahlster\"),沃尔夫迪特尔.卢卡斯(Wolf-Dieter Lukas)三位博士提出,由于\"产官学\"（ 产业界，政府，学术界）属性的与生俱来，很快便由德国工程院，弗劳恩获夫协会，西门子公司等接手，组成了工业4.0小组,于是工业4.0迅速的冲出了德国，走向了世界。所以\"工业4.0\"正是天时地利人和的结果。\n\n>&nbsp;&nbsp;&nbsp;&nbsp;这里插入一些我的人生观，不想听大道理的可以跳过了。其实很多事情都是水到而渠成的,尤其是知识积累更是如此。面对飞速发展的软件行业，作为初级程序员,很多人都想一口吃个胖子,想要快速的掌握开发技能,喜欢看速成的视频,教程，包括我也是如此,但很多时候却走了很多的弯路。因为基础知识不扎实而找东找西,就是一根筋的想要找和自己的问题一摸一样的解答，却不知道或者懒得去变通一下代码，或者花点时间去专研一下代码中的逻辑思维，从中受到启发。与其花半天时间去研读代码。却更愿意去花一天时间尝遍百度上的所有教程。\n\n>&nbsp;&nbsp;&nbsp;&nbsp;官方对于\"工业4.0\"的解释是,\"工业4.0包括将信息物理系统(Cyber physical System，CPS)技术一体化应用与制造业和物流行业,以及在工业生产过程中采用物联网和服务技术\"。从这段定义中个我们可以看到很熟悉的一个词\"物联网\",所以从此也可以看出以后的IT热门方向。物联网从前几年开始变得炙手可热，但发展一直没有想象中的那么迅猛，这和很多方面因素有关，包括硬件支持，传输技术，等等。但这丝毫不影响其发展趋势，因为物联网还是在不断发展的，而且越来越快,其模型成熟的时间决定着万物互联时代到来的时间。\"工业4.0\"产生的\"智能工厂\"和\"智能生产\"将改变传统的批量统一化的生产模式,实现高度灵活的个性化和数字化生产及服务，最终使生产更智能，更高效，跟快速，更经济。\n\n## ps1\n>由于我的手速有限，时间紧迫，今天只能谈到这。作为有点学术性质而又不深入具体细节的博客，希望大家能够当成故事看，了解当今的IT界的发展方向。我每天晚上会抽出11点之后断网的时间续写，第二点早上9点跟新,时间有限，我会尽快的完结。\n\n## <span id=\"two\"> 二、\"工业互联网\" VS \"工业4.0\"</span>\n>&nbsp;&nbsp;&nbsp;&nbsp;面对的德国的高歌猛进，世界第一大国美国怎能无动于衷了？毕竟在这个星球上主导权决定着发言权，就算是没有足够的主导权也不能牵制于人。由沙利文（Frost & Sullivan）这家咨询公司在一份报告中创造性的提出了“工业互联网”这个概念。也因此给沙利文公司在工业制造领域带来了话语权。公司还顺带的设立了“制造领袖奖”,2016年通用公司就很高兴的领了这个奖。2014年3月由通用电气（提供综合技术与服务）联合AT&T(M2M的解决方案)、Cisco(提供网络解决方案)、Intel(半导体、芯片和处理器)、IBM(智慧地球)成立了“工业互联网联盟(Industrial Internet Consortium,IIC)”。很显然工业互联网这块大蛋糕美国怎么会任由他人分割了,到2015年初，该联盟成员已经达到130家，西门子，华为等号称要自己做工业互联网平台的企业也没能抵制住诱惑。\n\n>&nbsp;&nbsp;&nbsp;&nbsp;很失望的是中国还是一如既往的落后与西方国家，作为发展中国家，不得不承认在先进技术和理念方面中国目前只能去模仿，距离成为“中国制造2025”目标中的世界一流的工业水准还是有很大的差距的。毕竟，不要说“工业4.0”，中国大部分企业还停留在“工业2.0”的水准，“工业3.0”水平也是很弱，这和很多因素有关，但我们还是对未来充满希望的，毕竟科技的快速发展网络的普及化，信息的透明化，以及人才的全球流通，给发展中国家带来的好处是可以快速的跟上队伍。我国并不缺少运行产业联盟的企业，但是成功的却非常少，其中企业自身创新能力弱，国际视野的局限性大是一方面，缺乏一个良好的利益共享机制，无法发挥每个企业的特长也是国内产业联盟难以落地的重要原因。\n\n>&nbsp;&nbsp;&nbsp;&nbsp;\"工业互联网\"和\"工业4.0\"中国到底应该站在哪一边了？这就要进一步的了解这两个热门词汇了。“工业互联网”可以说是自顶向下，侧重于利用互联网的技术来改善生产设备和产品服务。从物联网、云计算、大数据分析等信息技术的角度出发，将之应用于工业领域，改造工业生产的产品服务和管理过程等。“工业4.0”则是自下而上，侧重于在生产与制造过程的智能化、数字化。以生产设备为核心的CPS为出发点，推进数据融合和服务共享，从而推及工业生产过程以及产品服务等。虽然由于两国的的产业优势不同导致的工业互联网的结构正好颠倒，但其中的核心思想还是十分相似的。2016年3月，\"工业4.0平台\"和\"工业互联网联盟\"在瑞士苏黎世初步达成合作意向，开始了强强联合。这也是应了\"马太效应\"，\"凡有的，还要加给他，叫他有余；凡没有的，连他所有的也要夺去\"。\n\n## ps2\n>不知不觉已经12点了，为了不打扰舍友休息，今天就到这里。\n\n## <span id=\"three\"> 三、中国制造2025</span>\n>&nbsp;&nbsp;&nbsp;&nbsp;世界上很多国家都指定了符合本国国情的工业互联网规划，但基本上都是依据“工业4.0”或者“工业互联网”进行改编。同样，中国也不例外。“中国制造2025”以促进制造业创新发展为主题，以提质增效为中心，以加快新一代信息技术与制造业深度融合为主线，以推进智能制造为主攻方向，以满足经济社会发展和国防建设对重大技术装备的需求为目标，强化工业基础能力，提高综合集成水平，完善多层次多类型的培养体系，促进产业转型升级，培育有中国特色的制造文化，实现制造业由大变强的历史跨越。坚持“创新驱动、质量为先、绿色发展、结构优化、人才为本”的基本方针，坚持“市场主导、政府引导，立足当前、着眼长远，整体推进、重点突破，自主发展、开放合作”的基本原则，通过“三步走”实现制造强国的战略目标：第一步，到2025年迈入制造强国行列；第二步，到2035年中国制造业整体达到世界制造强国阵营中等水平；第三步，到新中国成立一百年时，综合实力进入世界制造强国前列。看到这一大推的雄伟措辞，不得不说中国最强的专家真的不是盖的，由50多位院士100多位领域专家共同指定的规划，将中国制造转变为中国智造的伟大目标高调的向全世界展示。\n\n>&nbsp;&nbsp;&nbsp;&nbsp;中国制造业的现状其实和国足相差无几，所以注定不能自上顶而下的对中国的工业基础进行改革，薄弱的工业基础实在是堪忧。从中国的物流业占GDP比重是美国德国的发达国家的两倍左右就可以看出其中的差距。所以“中国制造2025”更倾向于“工业4.0”的自下而上的进行改革。\n\n## <span id=\"forth\">四、工业革命升级技能点</span>\n>&nbsp;&nbsp;&nbsp;&nbsp;从技术角度上来说，第四次工业革命是一场从嵌入式系统到信息物理融合系统的技术变革，通过物联网，云计算，大数据在工业中的运用，促成基于网络化的变革。其关键的技术难点和重点在于实现智能化设备自知而治，泛在化网络（无处不在的网络）互联互通，中心化数据实时实效，开放化服务相辅相成，建立能够在联网对象彼此之间，网络对象和网络环境之间，联网对象和人之间共享的工业互联网，形成物联网，数据联网，服务联网以及人员联网的网络化开放平台。\n\n## PS3\n>第二遍浏览时发现想要阐述出书中的核心思想还是很难的，越来越发现写不下去了。所以还是得放下键盘，再仔细思考一番，理清思路。\n\n## <span id=\"firth\">五、人工智能</span>\n>&nbsp;&nbsp;&nbsp;&nbsp;谈到智能工业，智能电网，使用的往往是Smart这个词，而人工智能则使用Aritifical Intelligence（AI）。其原因是人工智能突出的是机器的反映方式能够类似人的智能。而半个世纪以来，人工智能的发展历程很坎坷，机器是否智能一直是一个很有争议的话题。之前之所以认为机器不具有智能是因为机器所完成的任务都是人类所定义好的，并没有超出人类的认知范围或者能力限制。而现在有些深度学习训练出来模型很多已经超出了人的认知范围，因为人能通过参数，阈值的对结果值进行調优，但是算法内部到底是怎样实现的却很难被人所知。随之而来的问题就是，不能够确保其训练出来的模型能够永远的正常使用，所以在金融行业，医疗行业等安全系数要求很高的行业中使用起来是需要对其进行风险评估的。\n\n>&nbsp;&nbsp;&nbsp;&nbsp;人工智能发展的阻碍主要有三个方面。第一、计算机的计算能力。随着硬件的不断升级计算计的运算能力显著提升，但是这不一定代表就可以解决全部的问题。仍然有很多无法优化的算法是需要大量的计算资源的，深度学习出来之后CPU就已经不适合用作为机器学习开发的硬件了，GPU（图形处理单元）将逐步的取代CPU在机器学习中的地位。第二、计算机对真实世界的感知能力。道现在为止人类研究的人工智能在“智力“上已经很高了，但是还是无法像人一样感知世界。对计算机而言实现逻辑推理等人类高级智慧只需要相对较少的计算能力，而现实感知、运动等人类低级智慧却需要巨大的计算资源。第三、推理和逻辑框架。人工智能也无法像人类一样在没有老师的情况下还能够自行的推理并且联想学习，也就是不具备迁移学习的能力。所以人工智能要模拟人的智能其难点不在于人脑进行的各种必然性推理，而是最能体现人的能动性和创造性的不确定推理。\n\n## <span id=\"six\">六、工业互联网的智能网络</span>\n>&nbsp;&nbsp;&nbsp;&nbsp;一个个孤立的点所包含的信息是很少的，但是将这些点之间相互连接起来，其中包含的信息量就极其巨大了。工业互联网的核心就是将原本割裂的工业数据实现流通，从而变成一个智能网络。我们可以概括为四个环节，即”感，联，知，控“。感，即感知层，机器，机组，物料，人员等物体之间能够相互感知，交互协作，从而实现不同生产实体之间的深度协同。联，即网络互联层，旨在将多元对象组成的异构复杂网络之间形成彼此互联互通的泛在化网络（可以简单理解为无处不在的网络）。知，即数据分析层，网络化的数据有些在传输过程中被即时处理，更多的是汇聚到中心节点后被集中处理。数据分析层负责工业大数据的存储、处理、建模、挖掘、和优化等方面。控，即开放服务层，基于工业大数据形成的决策依据，通过多种面向工业生产应用的开放式，共享型的标准化服务，被工业生产部门调用和实施，反馈到工业生产的各个环节，从而实现对工业生产的控制和调节。从网络角度出发，形成了实体联网，数据联网，服务联网的三重联网。\n\n### <span id=\"end\">七、结束语</span>\n\n>&nbsp;&nbsp;&nbsp;&nbsp;按照书本上的章节的话应该还有几章的内容没有讲到，主要内容是作者结合了中国工业的现状，对前几年发生的事情进行分析，对未来的展望。所以，到此为止就算是完结散花了。但总是感觉自己写的还很不到位，估计是因为心境的问题吧，有时候心境达不到，确实不能够写出什么深层次的东西，总是感觉很是词穷。下面又是我个人的主观瞎想了，没有兴趣的可以拜拜了。\n\n>&nbsp;&nbsp;&nbsp;&nbsp;有一句话叫做“软件定义世界”，而以后可能是“人工智能定义软件“。现在人工智能已经逐渐的深入到人们的生活当中来，语音识别，图像识别，等传统的机器学习任务现在使用深度学习对其进行训练，其在人脸识别，语音识别，游戏等很多方面已经超过了人类。所以深度学习的出现，可以说是又一次的焕发了机器学习的活力。毕竟人类从上个世界五六十年代一直到到现在在人工智能方面，能够显著的看出成果并取得重大突破的就是现在，几乎每天的新闻都是某某某使用深度学习神经网络实现了啥啥啥历史性的突破。\n而人工智能，大数据，云计算近几年来的火爆都不是”横空出世“的。个人觉得其最根本的原因在于互联。正是因为互联，所以数据呈现爆炸式的增长，所以单机的性能远远的不能满足大数据的需求。所以便出现了分布式集群，hadoop框架的诞生更是刺激了大数据的飞速发展。然而个人公司想要购置维护一个机器集群其话费可想而知，估计初创公司在第一步的购置硬件支持上就已经阻力重重了。这时候云计算平台的出现无异于雪中送炭，你只需要根据你所需要的服务，按照资源分配的多少，租用的时常，支付相应的费用便可，这样就大大的降低了业务快速上线的难度。云计算不仅仅给大数据提供了可扩展的平台，也是给人工智能提供了便捷，使得个人的算法实践能够方便，快捷，低成本的运行起来，而不必担心购买昂贵的GPU,显卡等硬件配置并且考虑使用完后的处置。我发像我已经犯困了，舍友以后也能好好睡觉了，完结。\n\n[1]: https://jchanji.github.io \"主页\"\n","tags":["Made in China 2025"],"categories":["-articals"]},{"title":"win10 安装ubuntu 16.04","url":"/year/09/03/install_ubuntu/","content":"\n## 前言\n>在win10下安装ubuntu双系统。在笔记本安装ubuntu的时候遇到了很多的挫折，曾经也放弃过，但很不幸的是，在未来的今天又碰上了。有时候问题的答案很简单，但是需要大量的时间去得到它，并不是你的能力不行，而是网上的干扰答案实在是太多，无法分辨谁对谁假的时候，往往会一个个的试过去。我不认为这是个很笨的方法，因为多花点时间总能体会更多的东西。貌似废话有点多，下面直接上干货。\n\n<!--more-->\n\n## 一、版本\n1. win10 企业版\n2. ubuntu 16.04\n3. UltraSO 9.6.6.3300\n4. 显卡：GTX 965M\n5. cup:i7-6700HQ\n\n\n## 二、下载\n1. [ubuntu 16.04](http://releases.ubuntu.com/16.04.2/ubuntu-16.04.2-desktop-amd64.iso?_ga=2.92867550.254780022.1497589112-1524410519.1497589112)\n2. [UltraSO](http://172.19.251.251/files/510300000015EB65/dl.softmgr.qq.com/original/Compression/uiso9_cn_9.6.6.3300.exe)\n\n## 三、安装配置\n\n### 1.将镜像刻录到u盘（至少4g）\n```markdown\n打开UltraSO，点击试用。\n1、文件->打开->镜像位置\n2、启动->写如硬盘映像->写入\n```\n### 2、分配空闲分区\n```markdown\n1、右击我的电脑->管理->磁盘管理\n2、选择非系统盘的主分区，右击->压缩卷，选择压缩大小，一般为50G,我的是100G,\n根据自己磁盘情况分配。\n```\n\n### 3、将电脑设置为U盘启动\n```markdown\n插入U盘，进入BIOS将U盘设置为启动项\n注：不同主板的BIOS大多都不会相同，所以根据自己电脑型号到网上查找。\n```\n### 4、安装系统\n#### 1、重新启动电脑，会进入安装界面，先择安装系统，进行安装。\n#### 2、卡在logo\n```markdown\n重新启动电脑，在选择系统安装的界面按e,进入grup界面，让后在splash后面加上：空格nomodeset空格，按F10执行。后面重启出了最后一次也是一样操作\n```\n#### 3、创建分区\n```markdwon\n1、选择自己分配的空闲的磁盘，进行分盘\n2、分盘的注意点是：\n    2.1、 /：存储系统文件，建议10GB ~ 15GB,我分配16G；\n    2.2、 swap：交换分区，即Linux系统的虚拟内存，建议是物理内存的2倍,我分配16G；\n    2.3、 /home：建议最后分配所有剩下的空间；\n    2.4、 boot：包含系统内核和系统启动所需的文件，实现双系统的关键所在，建议200M,我分配400M。\n3、其他的默认或者根据自己需求设置，点击安装\n```\n\n### 5、分辨率问题\n一般比较新的N（英伟达）卡会出现没有安装驱动的问题，所以屏幕的分率很低，这时候就需要安装N卡驱动。直接安装会导致开机的时候卡在登陆界面进不去，所以必须借助于bumblebee(大黄蜂)，至于原因有兴趣的可以查一查，这里不多阐述。\n```markdwon\nsudo apt-get install bumblebee bumblebee-nvidia primus linux-headers-generic\nReboot\n```\n重新启动后：\n```markdown\nsudo apt-get purge nvidia-* #删除所有的N卡驱动\nsudo add-apt-repository ppa:graphics-drivers/ppa  #添加第三方驱动源\nsudo apt-get update #更新源\nsudo  apt-cache search nvidia-*  #查询nvidia驱动可用版本，这里推荐到英伟达官网查看自己显卡驱动的版本，我的是375\nsudo apt-get install nvidia-375 # 安装驱动\n\n```\n打开软件更新器，然后将附加驱动－>未知换成显卡的驱动<br>\n最后重新启动，什么都不用做，等开机！\n\n\n[1]: https://jchanji.github.io \"主页\"\n\n","tags":["win 10"],"categories":["-others"]},{"title":"CentOS7 安装vnc","url":"/year/09/03/vnc/","content":"\n## 1.首先执行这一句防止系统文件被修改\n```markdown\nchattr +i /etc/resolv.conf\n```\n## 2、然后安装tigervnc\n```markdown\nsudo yum install -y tigervnc tigervnc-server\n```\n\n<!--more-->\n\n## 3.查看自己的服务器支持安装哪些包\n```markdown\nsudo yum grouplist\n```\n#### 查看自己的服务器里中Available Environment Groups下面有哪些可以安装的Desktop,我这里的是GNOME Desktop\n## 4. 安装GNOME Desktop\n```markdown\nsudo yum groupinstall GNOME Desktop\n```\n\n## 5. 启动服务\n```markdown\nvncserver\n```\n## 6.连接vnc \n>第一次执行会提示输入密码，然后再验证输入一次回车，vnc服务端就算搭建好了！\n接下来在手机或者电脑上下载vnc客户端，输入你的IP:5901连接\n然后输入密码就可以看到你的服务器界面了！\n\n","tags":["vnc"],"categories":["-others"]},{"title":"CentOS 7 安装eclipse mars 2","url":"/year/09/03/install_eclipse/","content":"\n#### 操作系统：CentOS 7\n#### eclispe版本：Eclipse Mars 2\n\n<!--more-->\n\n## 下载安装\n> ### 1.下载安装[eclipse][2]\n\n> ### 2.解压 \n\n```markdown\n sudo tar -zxvf [下载的安装包名称] -C [安装的目录]  \n```\n\n> ### 3.创建软链接\n\n```markdown\n sudo ln -s /安装的目录/eclipse/eclipse  /usr/bin/eclipse\n```\n\n> ### 4.添加图标\n\n```markdown\ngedit /usr/share/applications/eclipse.desktop\n```\n将下面内容添加到文件中\n```mrkdown\n[Desktop Entry]\nEncoding=UTF-8\nName=Eclipse\nComment=Eclipse Mar2\nExec=/usr/bin/eclipse\nIcon=/[解压的目录]/eclipse/icon.xpm\nCategories=Application;Development;Java;IDE\nVersion=1.0\nType=Application\nTerminal=0\n```\n\n\n[2]: http://mirrors.ustc.edu.cn/eclipse/technology/epp/downloads/release/mars/2/eclipse-jee-mars-2-linux-gtk-x86_64.tar.gz \"eclise下载\"","tags":["CentOS 7"],"categories":["-others"]},{"title":"伪分布式hbase安装配置","url":"/year/08/30/hbase_step/","content":"\n## 前言\n>网上有很多的教程，大体流程都差不多，但是在很多细节配置方面有点区别，本教程适用于伪分布式环境下（一般自己电脑上练习伪分布式够了）的hbase的基本安装配置。hadoop伪分布式环境已经搭建好,如果没有搭建好，推荐教程 [hadoop伪分布式教程](http://www.powerxing.com/install-hadoop-in-centos/),hbase官方[中文文档](http://abloz.com/hbase/book.html)\n\n<!--more-->\n\n## 一、版本\n\n1. CentOS7\n2. jdk:openjdk1.7.0_141\n2. hadoop：2.6.0\n3. hbase:0.98.13\n4. 一定要注意jdk,hadoop和hbase的版本匹配问题,可到官网查看！\n\n## 二、下载\n1.[hbase-0.98.13-hadoop2-bin.tar.gz](http://archive.apache.org/dist/hbase/0.98.13/hbase-0.98.13-hadoop2-bin.tar.gz)\n\n## 三、安装配置\n\n### 1、解压文件到指定目录\n```markdown\ntar -zxvf hbase-0.98.13-hadoop2-bin.tar.gz -C /usr/local\n```\n### 2、重命名\n```markdown\ncd /usr/local\nsudo mv [解压后的文件名] [hbase]\n```\n### 3、修改hbase-site.xml\n```markdown\ncd /hbase/conf\nsudo vim hbase-site.xml\n```\n将内容改为\n```markdown\n\n<configuration>\n<property>\n    <name>hbase.rootdir</name>\n    <value>hdfs://localhost:9000/hbase</value>\n  </property>\n  <property>\n    <name>hbase.zookeeper.property.dataDir</name>\n    <value>/usr/local/hbase/data/zkData</value>\n  </property>\n<property>\n    <name>hbase.cluster.distributed</name>\n    <value>true</value>\n  </property>\n</configuration>\n```\n说明：<br>\n1、很多教程的hbase.rootdir的hdfs的端口都和官网配置一样是8020，这里根据你自己的实际端口号配置，我的默认的为9000（一般都是），如果端口配置错误的话，之后的进程都能启动，但是在hdfs中没有创建hbase文件，也不能通过60010端口访问web UI.<br>\n2、dataDir的目录可以自己定义，不需要预先创建，hbase会根据配置自动生成。\n\n### 3、修改hbase-env.sh\n```markdown\nsudo vim hbase-env.sh\n```\n添加自己的JAVA_HOME路径\n```markdown\nexport JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk/\n```\n### 4、修改regionservers\n在/etc/hosts文件中添加主机名映射，再regionservers中默认的localhost改为主机名\n```mardown\nsudo vim etc/hosts\n```\n在最后一行添加 127.0.0.1 master\n```mardown\nsudo vim regionservers\n```\n将localhost改为mater</br>\n说明：如果ip映射出现问题后面的regionserver会启动不了\n\n### 5、启动服务\n首先先启动hadoop\n```markdown\nstart-all.sh\n```\n再启动hbase\n```markdown\ncd /usr/local/hbase/bin\n./hbase-daemon.sh start zookeeper\n./hbase-daemon.sh start regionserver\n./hbase-daemon.sh start master\n```\n### 6、查看web UI\n在浏览器中输入localhost:60010<br>\n如果能正常显示页面说明配置成功<br>\n说明：刚开启服务后由于hadoop处于安全模式导致不能访问，可以等几十秒再次访问或者通过命令\n```markdown\nhadoop dfsadmin -safemode leave \n```\n解除保护\n## 四、常用的一些命令\n\n### 1、从hdfs导入导出表\n```markdown\n1）导入\n./hbase org.apache.hadoop.hbase.mapreduce.Driver import 表名    数据文件位置\n\n2)导出\n./hbase org.apache.hadoop.hbase.mapreduce.Driver export 表名    数据文件位置\n```\n注意：直接操作会报没有jar包的错误，根据提示将hbase的jar包put进提示的hdfs路径中即可\n## 五、遇到的错误和解决办法\n\n### 1、无法启动HRegionServer和HMaster\n报错日志\n```markdown\n2017-06-13 19:10:12,458 ERROR [main] master.HMasterCommandLine: Master exiting\njava.lang.RuntimeException: Failed construction of Master: class org.apache.hadoop.hbase.master.HMaster\n  at org.apache.hadoop.hbase.master.HMaster.constructMaster(HMaster.java:3033)\n  at org.apache.hadoop.hbase.master.HMasterCommandLine.startMaster(HMasterCommandLine.java:193)\n  at org.apache.hadoop.hbase.master.HMasterCommandLine.run(HMasterCommandLine.java:135)\n  at org.apache.hadoop.util.ToolRunner.run(ToolRunner.java:70)\n  at org.apache.hadoop.hbase.util.ServerCommandLine.doMain(ServerCommandLine.java:126)\n  at org.apache.hadoop.hbase.master.HMaster.main(HMaster.java:3047)\nCaused by: java.net.BindException: 无法指定被请求的地址\n  at sun.nio.ch.Net.bind0(Native Method)\n  at sun.nio.ch.Net.bind(Net.java:463)\n  at sun.nio.ch.Net.bind(Net.java:455)\n  at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223)\n  at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74)\n  at org.apache.hadoop.hbase.ipc.RpcServer.bind(RpcServer.java:2488)\n  at org.apache.hadoop.hbase.ipc.RpcServer$Listener.<init>(RpcServer.java:590)\n  at org.apache.hadoop.hbase.ipc.RpcServer.<init>(RpcServer.java:1956)\n  at org.apache.hadoop.hbase.master.HMaster.<init>(HMaster.java:507)\n  at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n  at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)\n  at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n  at java.lang.reflect.Constructor.newInstance(Constructor.java:526)\n  at org.apache.hadoop.hbase.master.HMaster.constructMaster(HMaster.java:3028)\n  ... 5 more\n\n```\n解决办法\n```markdown\n我们可以看到Caused by: java.net.BindException: 无法指定被请求的地址，所以有可能是外网的的影响，所以先关闭网络连接，再启动服务，发现成功了，然后再开启网络。\n```\n### 2、启动hbase服务时找不到pid文件\n问题原因\n```markdown\n1. hbase进行大量的插入时region server 所分配的内存堆过小\n2. pid文件保存在tmp目录下容易丢失。\n```\n解决办法\n```markdown\n1. 在hb的hbase-env.sh中\n# The maximum amount of heap to use, in MB. Default is 1000.\n# export HBASE_HEAPSIZE=1000\n将1000改成30720\n\n2. 在hbase-env.sh中修改pid文件的存放路径：\n在hbase-env.sh中下面的文字默认是注释掉的，放开即可，也可以自己指定存放位置：\n# The directory where pid files are stored. /tmp by default.  \n export HBASE_PID_DIR=/var/hadoop/pids  \n```\n","tags":["hbase"],"categories":["-bigdata"]},{"title":"使用java将文件夹下的文件批量的从gbk编码转化成utf-8编码","url":"/year/08/30/codeparse_gbk2utf/","content":"## 前言\n\n>使用java,对文件遍历，修改文件编码\n\n<!--more-->\n\n### 一、建立java项目，导入[commons-io-*.jar][2]\n### 二、新建class，文件名随便起，我的是Codeparse,包名为exchangecode\n```markdown\npackage exchangecode;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collection;\n\nimport org.apache.commons.io.FileUtils;\n\npublic class Codeparse {\n\n    public static void main(String[] args) throws IOException {\n        //GBK编码格式源码路径,根据自己的文件路径写 \n        String srcDirPath = \"F:\\\\test\"; \n        //转为UTF-8编码格式源码路径，根据自己的文件路径写 \n        String utf8DirPath =\"F:\\\\out\"; \n                \n        //获取所有txt文件,如果是其他类型的文件，将{“txt”}中的txt换为其他文件的后缀名\n        @SuppressWarnings(\"unchecked\")\n        Collection<File> javaGbkFileCol =  FileUtils.listFiles(new File(srcDirPath), new String[]{\"txt\"}, true); \n                \n        for (File javaGbkFile : javaGbkFileCol) { \n              //UTF8格式文件路径 \n              String utf8FilePath = utf8DirPath+javaGbkFile.getAbsolutePath().substring(srcDirPath.length()); \n              \n              //使用GBK读取数据，然后用UTF-8写入数据 \n              FileUtils.writeLines(new File(utf8FilePath), \"UTF-8\", FileUtils.readLines(javaGbkFile, \"GBK\"));        \n        }\n        System.out.println(\"success!\");\n    }\n\n}\n```\n### 三、运行\n\n[2]: http://mirror.bit.edu.cn/apache//commons/io/binaries/commons-io-2.5-bin.zip \"commons-io-*.jar\"\n","tags":["-java"],"categories":["-others"]},{"title":"ubuntu16.04 anaconda环境下安装tensoflow(GPU)","url":"/year/08/29/tensorflow_step/","content":"## 前言\n>目前深度学习炙手可热的框架毫无疑问是tensorflow,在本教程主要介绍tensorflow在anaconda中的安装，在火车上实在是无聊，电脑又没有网络，只能打发一下时间。\n\n<!--more-->\n\n## 一、版本\n1. anaconda 4.3.21\n2. python 3.5\n3. tensorflow 1.2.0(github上目前最新版本)\n4. ubuntu 16.04\n## 二、下载\n1. [Anaconda3-4.4.0-Linux-x86_64.sh]()\n2. [tensorflow_gpu-1.2.1-cp35-cp35m-linux_x86_64.whl]()\n##三、注意事项\n```markdown\n1、电脑上已经安装了cadu8.0和cudnn5.1环境\n2、tensorflow1.2.0版本支持cadu8.0,其他低版本的tensorflow会发生找不到依赖的错误。\n３、安装后运行会出现CPU computations,cpu指令集优化的警告，目前没有很好的解决办法，不过影响不大，因为我们主要使用的是GPU.\n```\n## 四、安装配置\n\n### 1、安装anaconda\n```markdown\nsudo bash Anaconda3-4.4.0-Linux-x86_64.sh\n```\n\n### 2、　安装python3.5环境\n```markdown\nconda create -n tensorflow python = 3.5\n```\n### 3、安装tensorflow\n```markdown\nsource activate tensorflow #进入刚才安装好的环境\ncd ~/下载　＃进入tensorflow　的pip安装文件的目录\npip install tensorflow_gpu-1.2.1-cp35-cp35m-linux_x86_64.whl #安装tensorflow\n```\n\n## 五、测试\n进入python环境\n```markdown\npython\n```\n运行代码\n```python\nimport tensorflow as tf\nsess = tf.Session()\n\na = tf.constant(10)\nb = tf.constant(20)\n\nprint(sess.run(a+b))\n```\n输出结果\n```markdown\n3\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["tensorflow"],"categories":["-machinelearning"]},{"title":"K-means算法-对31省消费水平分类","url":"/year/08/29/citycosumption/","content":"## 前言：\n>此篇笔记主要根据南京大学礼欣老师的[《Python机器学习应用》](http://www.icourse163.org/learn/BIT-1001872001?tid=1001965001#/learn/announce)整理而成，详细内容请看礼欣老师的mooc课程。\n\n<!--more-->\n\n## 数据介绍：\n现有1999年全国31个省份城镇居民家庭平均每人全年消费性支出的八个主\n要变量数据，这八个变量分别是：食品、衣着、家庭设备用品及服务、医疗\n保健、交通和通讯、娱乐教育文化服务、居住以及杂项商品和服务。利用已\n有数据，对31个省份进行聚类。。数据下载[点击我](https://github.com/jChanJi/static_resource/blob/master/clustering/TestData.txt)\n\n## 主要参数\n1. n_clusters：用于指定聚类中心的个数\n2. init：初始聚类中心的初始化方法\n3. max_iter：最大的迭代次数\n4. 一般调用时只用给出n_clusters即可，init\n默认是k-means++，max_iter默认是300\n5. data：加载的数据\n6. label：聚类后各数据所属的标签\n7. axis: 按行求和\n8. fit_predict()：计算簇中心以及为簇分配序号\n\n## 代码\n```python\nimport numpy as np\nfrom sklearn.cluster import KMeans\n\n\ndef loadData(filePath):\n    fr = open(filePath,'r+')\n    lines = fr.readlines()\n    retData = []\n    retCityName = []\n    for line in lines:\n        items = line.strip().split(\",\")\n        retCityName.append(items[0])\n        retData.append([float(items[i]) for i in range(1,len(items))])\n    return retData,retCityName\n\n\nif __name__ == '__main__':\n    data,cityName = loadData('F:/data/clustering/city.txt')\n    km = KMeans(n_clusters=4)\n    label = km.fit_predict(data)\n    expenses = np.sum(km.cluster_centers_,axis=1)\n    #print(expenses)\n    CityCluster = [[],[],[],[]]\n    for i in range(len(cityName)):\n        CityCluster[label[i]].append(cityName[i])\n    for i in range(len(CityCluster)):\n        print(\"Expenses:%.2f\" % expenses[i])\n        print(CityCluster[i])\n```\n\n## 结果\n```markdown\nExpenses:4441.04\n['安徽', '湖南', '湖北', '广西', '海南', '四川', '云南']\nExpenses:7754.66\n['北京', '上海', '广东']\nExpenses:5567.33\n['天津', '江苏', '浙江', '福建', '重庆', '西藏']\nExpenses:3788.76\n['河北', '山西', '内蒙古', '辽宁', '吉林', '黑龙江', '江西', '山东', '河南', '贵州', '陕西', '甘肃', '青海', '宁夏', '新疆']\n\n```\n\n## 注：当改变簇n_clusters为8(CityCluster长度也设置为8)时结果\n```python\nExpenses:3497.85\n['山西', '内蒙古', '黑龙江', '河南', '宁夏']\nExpenses:5311.98\n['天津', '江苏', '重庆', '云南']\nExpenses:7010.02\n['北京', '浙江']\nExpenses:7517.80\n['广东']\nExpenses:4357.67\n['安徽', '湖南', '湖北', '广西', '海南', '四川']\nExpenses:5287.90\n['福建', '西藏']\nExpenses:8247.69\n['上海']\nExpenses:3934.21\n['河北', '辽宁', '吉林', '江西', '山东', '贵州', '陕西', '甘肃', '青海', '新疆']\n\n```\n我们发现簇多所分的层次就越多\n","tags":["K-means"],"categories":["-machinelearning"]},{"title":"CentOS7安装配置hadoop集群","url":"/year/08/29/hadoop/","content":"\n## 基本操作\n### [简单的的vim命令](http://www.cnblogs.com/jeakon/archive/2012/08/13/2816802.html)\n### [linux常用命令](http://www.weixuehao.com/archives/25)\n### [linux命令查找网站](http://man.linuxde.net/)\n\n# CentOS 下安装hadoop<br>\n\n<!--more-->\n\n## 一、安装Vmware 12\n> 1. 官网下载[VMware-Workstation-Full-*.bundle][2]\n> 2. sudo ssh./VMware-Workstation-Full-*.bundle\n> 3. 破解：破解工具[VMware12.Keymaker][3] \n> 4. 根据提示安装\n\n## 二、安装CentOS 7\n> 1. 下载[镜像][4]\n> 2. 新建虚拟机，根据提示操作（注意选择安装GNOME桌面），设置主机名为CentOSMaster点击安装\n> 3. 设置root密码和添加hadoop用户（设置为管理员）\n> 4. 等待安装，完成后重启，连接网络，完成配置 \n> 5. 语言选择汉语（pinyin）\n\n## 三、 安装hadoop集群\n#### 参考教程：\n#### 单机/伪分布式：<http://www.powerxing.com/install-hadoop-in-centos/>\n#### 分布式集群：<http://www.powerxing.com/install-hadoop-cluster/>\n\n>### 1. 创建hadoop用户(如果没有)\n\n```markdown\n1. su                               # 上述提到的以 root 用户登录\n2. useradd -m hadoop -s /bin/bash   # 创建新用户hadoop\n3. passwd hadoop                    #设置密码\n4. visudo                           #增加管理员权限\n```\n找到 root  ALL=(ALL)  ALL 这行,下一行增加:hadoop ensp; ensp; ALL=(ALL)  ensp;ensp; ALL<br>\n\n>### 2. 安装Java环境(在hadoop用户下)\n\n1. 安装openjdk<br>\n```markdown\n    sudo yum install java-1.7.0-openjdk java-1.7.0-openjdk-devel\n```\n如果遇到yum进程被占用，删除yum.pid\n```markdown\n    sudo rm -rf /var/run/yum.pid\n```\n2. 配置JAVA_HOME<br>\n```markdown\n    vim ~/.bashrc\n```\n    在文件最后面添加如下单独一行（指向 JDK 的安装位置)<br>\n```markdown\n    export JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk\n```\n3. 使配置生效<br>\n```markdown\n    source ~/.bashrc\n```\n4. 检验是否配置成功<br>\n```markdown\n   echo $JAVA_HOME  #检验变量值\n   java -version \n   %JAVA_HOME/bin/java -version\n```\n如果java -version 和 %JAVA_HOME/bin/java -version一样表示成功,否则看5<br><br>\n5. 如果和以前的jdk版本冲突的:<br>\n    查找当前的安装的jdk版本<br>\n```markdown\n    rpm -q |grep java\n```  \n    删除openjdk版本意外的版本<br>\n```markdown\n    rpm -e --nodeps java版本的名称\n```  \n\n>### 3.安装配置hadoop2集群\n\n1. 下载hadoop压缩包，选择[hadoop-2.x.y.tar.gz][5]文件,这里我选择的是2.6.1版本<br><br>\n2. 解压<br>\n```markdown\n    sudo tar -zxf ~/下载/hadoop-2.6.1.tar.gz -C /usr/local    # 解压到/usr/local中\n    cd /usr/local/  #打开/usr/local目录\n    sudo mv ./hadoop-2.6.1/ ./hadoop  # 将文件夹名改为hadoop\n    sudo chown -R hadoop:hadoop ./hadoop  # 修改文件权限，冒号后没有空格\n```\n4. 显示版本<br>\n```markdown\n    cd  /usr/local/hadoop\n    ./bin/hadoop version\n```\n5. 配置环境变量<br>\n```markdown\n    gedit ~/.bashrc (vim ~/.bashrc)\n```\n    在文件中添加：<br>\n```markdown\n    #Hadoop Environment Variables\n    export HADOOP_HOME=/usr/local/hadoop\n    export HADOOP_INSTALL=$HADOOP_HOME\n    export HADOOP_MAPRED_HOME=$HADOOP_HOME\n    export HADOOP_COMMON_HOME=$HADOOP_HOME\n    export HADOOP_HDFS_HOME=$HADOOP_HOME\n    export YARN_HOME=$HADOOP_HOME\n    export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native\n    export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin\n```\n6. 使配置生效<br>\n```markdown\n    source ~/.bashrc\n    hadoop version #验证\n```\n7. 关闭虚拟机，克隆两个虚拟机，命名为CentOSSlave1,CentOSSlave2,注意要选择完整克隆<br><br>\n8. 依次打开CentOSMaster,CentOSSlave1,CentOSSlave2,查看各自的ip,(ens**下的inet内容)<br>\n```markdown\n    ifconfig\n```   \n9. 修改各自的主机名(Matser，Slave1，Slave2)：<br>\n在master节点上：<br>\n```markdown\n    sudo hostnamectl  set-hostname Master\n```\n在Slave1节点上：<br>\n```markdown\n    sudo hostnamectl  set-hostname Slave1\n```\n在Slave2节点上：<br>\n```markdown\n    sudo hostnamectl  set-hostname Slave2\n```\n10. 修改ip映射（三个节点都要修改）：<br>\n```markdown\n    sudo vim /etc/hosts\n```\n    在末尾加上:<br>\n```markdown\n   ip1   Master\n   ip2   Slave1\n   ip3   Slave2\n```\n11. 设置开机启动网络<br>\n    修改 /etc/sysconfig/network-scripts/ifcfg-ens*（具体文件名每个人有可能不同）,将最后一行的ONBOOT 改为yes    \n```markdown\n    vim  /etc/sysconfig/network-scripts/ifcfg-ens33  #我的文件名称为ifcfg-ens33\n``` \n12. 通过在终端分别执行ping Master，ping Slave1，ping Slave2,看是否能通，ctrl+C停止<br><br>\n13. 主节点Master使用ssh无密钥登陆节点（注意ssh登陆的用户名）<br><br>\n    a. 首先生成 Master 节点的公匙，在 Master 节点的终端中执行：<br>\n```markdown\n       su hadoop               #登陆到hadoop用户,所有操作都使hadoop用户的行为\n       cd ~/.ssh               # 如果没有该目录，先执行一次ssh Master\n       rm ./id_rsa*            # 删除之前生成的公匙（如果有）\n       ssh-keygen -t rsa       # 一直按回车就可以\n```\n    b. 让Master节点需能无密码ssh本机，在 Master 节点上执行：<br>\n```markdown\n       cat ./id_rsa.pub >> ./authorized_keys\n       chmod 600 ./authorized_keys    # 修改文件权限\n```\n      完成后可执行 ssh Master 验证一下（可能需要输入 yes，成功后执行 exit 返回原来的终端）。<br><br>\n    c. 将上公匙传输到 Slave1 节点(Slave2也是一样操作将Slave1改成Slave2):<br>\n```markdown\n       scp ~/.ssh/id_rsa.pub hadoop@Slave1:/home/hadoop/<br><br>\n``` \n    d. 在Slave1和Slave2节点上 操作：<br>\n```markdown\n       mkdir ~/.ssh       # 如果不存在该文件夹需先创建，若已存在则忽略\n       cat ~/id_rsa.pub >> ~/.ssh/authorized_keys\n       rm ~/id_rsa.pub    # 用完就可以删掉了\n````\n    e. 在Master节点上ssh Slave1和Slave2，验证是否能连接上<br><br>\n```markdown\n    ssh Slave1\n    \n    ssh Slave2\n```\n14. 在Master节点上操作，cd /usr/local/hadoop/etc/hadoop,进入root模式<br>\n    a. 修改slaves文件,将localhost注释，添加Slave1,换行，Slave2<br><br>\n```markdown\n    vim slaves\n```\n    b. 修改core-site.xml<br>\n    ```markdown\n    <configuration>\n           <property>\n                <name>fs.defaultFS</name>\n                <value>hdfs://Master:9000</value>\n            </property>\n            <property>\n                <name>hadoop.tmp.dir</name>\n                <value>file:/usr/local/hadoop/tmp</value>\n                <description>tmp directories</description>\n            </property>\n    </configuration>\n    ```\n    c. 修改hdfs-site.xml,其中的dfs.replication的value根据Slave的个数填写<br>\n    ```html\n     <configuration>\n            <property>\n                    <name>dfs.namenode.secondary.http-address</name>\n                    <value>Master:50090</value>\n            </property>\n            <property>\n                    <name>dfs.replication</name>\n                    <value>2</value>\n            </property>\n            <property>\n                    <name>dfs.namenode.name.dir</name>\n                    <value>file:/usr/local/hadoop/tmp/dfs/name</value>\n            </property>\n            <property>\n                    <name>dfs.datanode.data.dir</name>\n                    <value>file:/usr/local/hadoop/tmp/dfs/data</value>\n            </property>\n      </configuration>\n    ````\n    d. 重命名 mapred-site.xml.template为mapred-site.xml,并修改mapred-site.xml为：<br>\n    ```html\n    <configuration>\n            <property>\n                    <name>mapreduce.framework.name</name>\n                    <value>yarn</value>\n            </property>\n            <property>\n                    <name>mapreduce.jobhistory.address</name>\n                    <value>Master:10020</value>\n            </property>\n            <property>\n                    <name>mapreduce.jobhistory.webapp.address</name>\n                    <value>Master:19888</value>\n            </property>\n    </configuration>\n    ````\n    e. 修改yarn.site.xml为：<br>\n    ```html\n    <configuration>\n            <property>\n                    <name>yarn.resourcemanager.hostname</name>\n                    <value>Master</value>\n            </property>\n            <property>\n                    <name>yarn.nodemanager.aux-services</name>\n                    <value>mapreduce_shuffle</value>\n            </property>\n    </configuration>\n    ```\n15. 配置好后,将Master上的/usr/local/hadoop文件夹复制到各个节点上。如果有临时文件和日志文件先删除,在Master节点上执行:<br>\n```markdown\n    cd /usr/local\n    sudo rm -r ./hadoop/tmp                    # 删除 Hadoop 临时文件\n    sudo rm -r ./hadoop/logs/*                 # 删除日志文件\n    tar -zcf ~/hadoop.master.tar.gz ./hadoop   # 先压缩再复制\n    cd ~\n    scp ./hadoop.master.tar.gz Slave1:/home/hadoop\n```\n    如果有其他节点再执行：scp ./hadoop.master.tar.gz Slave(n):/home/hadoop<br><br>\n16. 分别在slave节点上执行<br>\n```markdown\n    sudo rm -r /usr/local/hadoop    # 删掉旧的（如果存在）\n    sudo tar -zxf ~/hadoop.master.tar.gz -C /usr/local\n    sudo chown -R hadoop /usr/local/hadoop   #给hadoop用户读写/usr/local/hadoop的权限\n```\n17. 首次启动需要先在 Master 节点执行 NameNode 的格式化：<br>\n```markdown\n    hdfs namenode -format       # 首次运行需要执行初始化，之后不需要，status=0，表示成功\n```\n18. 关闭防火墙(所有机器)：<br>\n```markdown\n    systemctl stop firewalld.service    # 关闭firewall<\n    systemctl disable firewalld.service # 禁止firewall开机启动\n```\n19. 启动服务<br>\n```markdown\n   start-yarn.sh\n   start-dfs.sh\n   mr-jobhistory-daemon.sh start historyserver\n```\n20. 在master节点上查看java进程<br>\n```markdown\n    jps\n```\n    如果有JobHistoryServer,SecondaryNameNode,Jsp,ResourceManager,NameNode四个进程代表Master上没问题<br><br>\n21. 在slave节点上执行<br>\n```markdown\n    jps\n```\n    如果有Jps，DataNode,NodeManager,三个节点表示配置成功<br><br>\n22. 关闭服务<br>\n```markdown\n    stop-yarn.sh\n    stop-dfs.sh\n    mr-jobhistory-daemon.sh stop historyserver\n```\n\n\n[2]: http://www.vmware.com/cn/products/workstation/workstation-evaluation.html \"Vmware 下载地址\"\n[3]: http://chanji-1252400803.costj.myqcloud.com/VMware12.Keymaker.exe \"VMware12.Keymaker\"\n[4]: http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1611.iso \"CentOS 7\"\n[5]: http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-2.6.1/hadoop-2.6.1.tar.gz \"hadoop\"","tags":["big data"],"categories":["-bigdata"]},{"title":"Hello World","url":"/year/08/29/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]